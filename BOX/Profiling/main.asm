; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	d:\___x\hack\appupdt\box\box\box\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@ ; `string'
EXTRN	__imp__malloc:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__perror:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__clock:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__ftell:PROC
;	COMDAT ??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@ DB '%'
	DB	'ld -> %ld in %1.2f sec.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@ DB '<'
	DB	'exe> c/d <input> <output>', 0aH, 00H	; `string'
CONST	ENDS
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_main
PUBLIC	?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z	; output_proc
PUBLIC	?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z	; input_proc
PUBLIC	?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_decompress
PUBLIC	?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_compress
PUBLIC	?box_workmem_size@@YAKXZ			; box_workmem_size
PUBLIC	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
PUBLIC	?decompress@box_unbox@@IAEXXZ			; box_unbox::decompress
PUBLIC	?decode_lit@box_unbox@@IAEKK@Z			; box_unbox::decode_lit
PUBLIC	?decode@box_unbox@@IAEKK@Z			; box_unbox::decode
PUBLIC	?fill_x@box_unbox@@IAEXXZ			; box_unbox::fill_x
PUBLIC	?_shift_in@box_unbox@@IAEXXZ			; box_unbox::_shift_in
PUBLIC	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
PUBLIC	?compress@box_mkbox@@IAEXXZ			; box_mkbox::compress
PUBLIC	?code_lit@box_mkbox@@IAEXKK@Z			; box_mkbox::code_lit
PUBLIC	?code_one@box_mkbox@@IAEXK@Z			; box_mkbox::code_one
PUBLIC	?code_zero@box_mkbox@@IAEXK@Z			; box_mkbox::code_zero
PUBLIC	?code@box_mkbox@@IAEXKK@Z			; box_mkbox::code
PUBLIC	?flush@box_mkbox@@IAEXXZ			; box_mkbox::flush
PUBLIC	?_shift_out@box_mkbox@@IAEXXZ			; box_mkbox::_shift_out
PUBLIC	??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z	; box_io::box_io
PUBLIC	?io_final@box_io@@IAEXXZ			; box_io::io_final
PUBLIC	?io_init@box_io@@IAEXXZ				; box_io::io_init
PUBLIC	?_putchr@box_io@@IAEXK@Z			; box_io::_putchr
PUBLIC	?_getchr@box_io@@IAEKXZ				; box_io::_getchr
PUBLIC	?_flushbuf@box_io@@IAEXXZ			; box_io::_flushbuf
PUBLIC	?_fillbuf@box_io@@IAEXXZ			; box_io::_fillbuf
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__PogoVCallTable
PUBLIC	__real@408f400000000000
EXTRN	__PogoGlobalProbes:PROC
EXTRN	__PogoRuntimeVector:PROC
EXTRN	___PogoPopAllXmm@0:PROC
EXTRN	___PogoPushAllXmm@0:PROC
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
rdata	SEGMENT
__PogoVCallTable DD FLAT:?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
	DD	FLAT:?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
	DD	FLAT:___local_stdio_printf_options
	DD	FLAT:_main
rdata	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT
; MDS probes
; __Stream$ = ecx
; __Format$ = edx

; 640  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	push	72					; 00000048H
	call	DWORD PTR __PogoRuntimeVector+16

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	call	DWORD PTR __imp____stdio_common_vfprintf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 642  :     }

	pop	ebp
	mov	ecx, DWORD PTR [esp]
	mov	DWORD PTR [esp+8], ecx
	add	esp, 8
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?io_init@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_init@box_io@@IAEXXZ PROC				; box_io::io_init, COMDAT
; MDS probes
; _this$ = ecx

; 149  : 	__inline__ void io_init() {

	push	ebp
	mov	ebp, esp
	push	56					; 00000038H
	call	DWORD PTR __PogoRuntimeVector+16

; 150  : 		input->count = 0; // reset count

	mov	eax, DWORD PTR [ecx]

; 151  : 		output->count = 0; // reset count
; 152  : 		_fillbuf();

	push	DWORD PTR [ebp+12]
	push	1
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 153  : 	}

	pop	ebp
	ret	8
?io_init@box_io@@IAEXXZ ENDP				; box_io::io_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?io_final@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_final@box_io@@IAEXXZ PROC				; box_io::io_final, COMDAT
; MDS probes
; _this$ = ecx

; 156  : 	__inline__ void io_final() {

	push	ebp
	mov	ebp, esp
	push	80					; 00000050H
	call	DWORD PTR __PogoRuntimeVector+16

; 157  : 		if (output->count != 0) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@io_final

; 158  : 			_flushbuf();

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
$LN2@io_final:

; 159  : 		}
; 160  : 	}

	pop	ebp
	ret	8
?io_final@box_io@@IAEXXZ ENDP				; box_io::io_final
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?flush@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?flush@box_mkbox@@IAEXXZ PROC				; box_mkbox::flush, COMDAT
; MDS probes
; _this$ = ecx

; 197  : 	__inline__ void flush() {

	push	ebp
	mov	ebp, esp
	push	96					; 00000060H
	call	DWORD PTR __PogoRuntimeVector+16

; 198  : 		_putchr(x1 >> 24);

	movzx	eax, BYTE PTR [ecx+23]
	push	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 199  : 	}

	pop	ebp
	ret	8
?flush@box_mkbox@@IAEXXZ ENDP				; box_mkbox::flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?fill_x@box_unbox@@IAEXXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
tv71 = -4						; size = 4
?fill_x@box_unbox@@IAEXXZ PROC				; box_unbox::fill_x, COMDAT
; MDS probes
; _this$ = ecx

; 329  : 	__inline__ void fill_x() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
	push	120					; 00000078H
	call	DWORD PTR __PogoRuntimeVector+16

; 330  : 		for (int i = 0; i < 4; ++i) {

	xor	esi, esi
	mov	DWORD PTR tv71[ebp], 32			; 00000020H
	npad	5
$LL4@fill_x:
	cmp	esi, 4
	jge	SHORT $LN3@fill_x
	mov	DWORD PTR tv71[ebp], 24			; 00000018H

; 331  : 			x = (x << 8) | (_getchr() & 0xFF);

	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	movzx	ecx, al
	mov	eax, DWORD PTR [edi+28]
	shl	eax, 8
	or	eax, ecx
	inc	esi
	mov	DWORD PTR [edi+28], eax
	jmp	SHORT $LL4@fill_x
$LN3@fill_x:

; 330  : 		for (int i = 0; i < 4; ++i) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv71[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	pop	edi
	pop	esi

; 332  : 		}
; 333  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?fill_x@box_unbox@@IAEXXZ ENDP				; box_unbox::fill_x
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?decompress@box_unbox@@IAEXXZ
_TEXT	SEGMENT
_hash$1$ = -4						; size = 4
?decompress@box_unbox@@IAEXXZ PROC			; box_unbox::decompress, COMDAT
; MDS probes
; _this$ = ecx

; 368  : 	__inline__ void decompress() {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	push	184					; 000000b8H
	call	DWORD PTR __PogoRuntimeVector+16

; 369  : 		x1 = 0; x2 = 0xFFFFFFFF;
; 370  : 		htbl = mem->htbl;

	mov	ecx, DWORD PTR [esi+8]

; 371  : 		ptbl = mem->ptbl;
; 372  : 
; 373  : 		fillmem(htbl, HASH_SIZE, (U32) 0);

	mov	edx, 262144				; 00040000H
	push	0
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+20], 0
	lea	eax, DWORD PTR [ecx+1048576]
	mov	DWORD PTR [esi+24], -1
	push	56					; 00000038H
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], eax
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 374  : 		fillmem(ptbl, SM_SIZE, (U32) 1 << 31);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, 1056768				; 00102000H
	push	-2147483648				; 80000000H
	push	DWORD PTR [ebp+12]
	push	55					; 00000037H
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 375  : 		io_init();

	mov	eax, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, esi
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [esi+4]
	push	54					; 00000036H
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf

; 376  : 		fill_x();

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	50					; 00000032H
	call	?fill_x@box_unbox@@IAEXXZ		; box_unbox::fill_x
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 377  : 
; 378  : 		U32 hash = 0, smc = 0, cxt = 0;

	xor	edi, edi
	mov	DWORD PTR _hash$1$[ebp], 0
	xor	ebx, ebx
	npad	2
$LL2@decompress:

; 379  : 		while (1) {
; 380  : 			U32 chr;
; 381  : 			if (decode(smc) == 0) { // match first?

	push	edi
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	46					; 0000002eH
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	test	eax, eax
	jne	SHORT $LN4@decompress

; 382  : 				chr = cxt & 0xFF;

	movzx	edx, bl

; 383  : 				cxt += (cxt < MATCH_MAX) ? MATCH_INC : 0; // increment count

	cmp	ebx, 251658240				; 0f000000H
	jae	SHORT $LN13@decompress
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	mov	eax, 16777216				; 01000000H
	jmp	SHORT $LN14@decompress
$LN13@decompress:
	xor	eax, eax
$LN14@decompress:
	add	ebx, eax
	jmp	$LN11@decompress
$LN4@decompress:

; 384  : 			} else if (decode(smc + 1) == 0) { // literal?

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	42					; 0000002aH
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax
	test	eax, eax
	jne	SHORT $LN6@decompress

; 385  : 				chr = decode_lit(smc + 2);

	lea	eax, DWORD PTR [edi+2]
	mov	ecx, esi
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	5
	call	?decode_lit@box_unbox@@IAEKK@Z		; box_unbox::decode_lit
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax
	mov	edx, eax

; 386  : 				if (chr != (cxt & 0xFF)) {

	movzx	ecx, bl
	cmp	edx, ecx
	je	$LN8@decompress

; 387  : 					cxt = ((cxt << 8) & 0xFFFF00) | chr;

	movzx	ebx, bx
	shl	ebx, 8
	or	ebx, edx

; 388  : 				} else {
; 389  : 					break;
; 390  : 				}

	jmp	SHORT $LN11@decompress
$LN6@decompress:

; 391  : 			} else if (decode(smc + 2) == 0) { // match second?

	lea	eax, DWORD PTR [edi+2]
	mov	ecx, esi
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+80], 1
	adc	DWORD PTR [eax+84], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	38					; 00000026H
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+88], 1
	adc	DWORD PTR [eax+92], 0
	pop	eax
	test	eax, eax
	jne	SHORT $LN10@decompress

; 392  : 				chr = (cxt >> 8) & 0xFF;

	mov	eax, ebx
	shr	eax, 8
	movzx	edx, al

; 393  : 				cxt = (cxt & 0xFF0000) | ((cxt << 8) & 0x00FF00) | chr | MATCH_INC;

	movzx	eax, bl
	and	ebx, 16711680				; 00ff0000H
	or	eax, 65536				; 00010000H
	shl	eax, 8
	or	eax, ebx
	or	eax, edx
	mov	ebx, eax

; 394  : 			} else { // match third?

	jmp	SHORT $LN11@decompress
$LN10@decompress:

; 391  : 			} else if (decode(smc + 2) == 0) { // match second?

	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+96], 1
	adc	DWORD PTR [eax+100], 0

; 395  : 				chr = (cxt >> 16) & 0xFF;

	mov	eax, ebx

; 396  : 				cxt = ((cxt << 8) & 0xFFFF00) | chr | MATCH_INC;

	movzx	ebx, bx
	shr	eax, 16					; 00000010H
	or	ebx, 65536				; 00010000H
	movzx	edx, al
	shl	ebx, 8
	or	ebx, edx
$LN11@decompress:

; 397  : 			}
; 398  : 			htbl[hash] = cxt;

	mov	ecx, DWORD PTR _hash$1$[ebp]
	mov	eax, DWORD PTR [esi+12]

; 399  : 			hash = (((hash * 5) << HASH_SHIFT) + chr) & HASH_MASK;
; 400  : 			cxt = htbl[hash];
; 401  : 			smc = ((chr << 4) | (cxt >> 24)) * SM_PART;
; 402  : 			_putchr(chr);

	push	edx
	mov	DWORD PTR [eax+ecx*4], ebx
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	ebx, DWORD PTR [esi+12]
	mov	eax, edx
	shl	ecx, 6
	add	ecx, edx
	shl	eax, 4
	and	ecx, 262143				; 0003ffffH
	mov	DWORD PTR _hash$1$[ebp], ecx
	mov	ebx, DWORD PTR [ebx+ecx*4]
	mov	ecx, ebx
	shr	ecx, 24					; 00000018H
	or	ecx, eax
	imul	edi, ecx, 258
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+104], 1
	adc	DWORD PTR [eax+108], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	3
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+112], 1
	adc	DWORD PTR [eax+116], 0
	pop	eax

; 403  : 		}

	jmp	$LL2@decompress
$LN8@decompress:

; 404  : 		// output remain buffer
; 405  : 		io_final();

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+120], 1
	adc	DWORD PTR [eax+124], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?io_final@box_io@@IAEXXZ		; box_io::io_final
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+128], 1
	adc	DWORD PTR [eax+132], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 406  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?decompress@box_unbox@@IAEXXZ ENDP			; box_unbox::decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?decode_lit@box_unbox@@IAEKK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_smc$ = 16						; size = 4
?decode_lit@box_unbox@@IAEKK@Z PROC			; box_unbox::decode_lit, COMDAT
; MDS probes
; _this$ = ecx

; 352  : 	__inline__ U32 decode_lit(U32 smc) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	push	176					; 000000b0H
	call	DWORD PTR __PogoRuntimeVector+16

; 353  : 		// decode high 4 bits in contexts cxt+1..15
; 354  : 		U32 hi = 2 + decode(smc + 1);

	mov	ebx, DWORD PTR _smc$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	DWORD PTR [ebp+12]
	push	29					; 0000001dH
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	mov	esi, eax
	add	esi, 2

; 355  : 		hi += hi + decode(smc + hi);

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	push	DWORD PTR [ebp+12]
	mov	ecx, edi
	push	25					; 00000019H
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 356  : 		hi += hi + decode(smc + hi);

	mov	ecx, edi
	lea	esi, DWORD PTR [eax+esi*2]
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	push	21					; 00000015H
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 357  : 		hi += hi + decode(smc + hi);

	mov	ecx, edi
	lea	esi, DWORD PTR [eax+esi*2]
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	push	17					; 00000011H
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	lea	edi, DWORD PTR [eax+esi*2]

; 358  : 		// decode low 4 bits in one of 16 blocks of 15 cxts
; 359  : 		smc += 15 * (hi - 15);

	lea	ecx, DWORD PTR [edi-15]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx

; 360  : 		U32 lo = 2 + decode(smc + 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	add	ebx, eax
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	DWORD PTR [ebp+12]
	push	13					; 0000000dH
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	pop	eax
	mov	esi, eax
	add	esi, 2

; 361  : 		lo += lo + decode(smc + lo);

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	push	DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	9
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax
	lea	esi, DWORD PTR [eax+esi*2]

; 362  : 		lo += lo + decode(smc + lo);

	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	5
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax

; 363  : 		lo += lo + decode(smc + lo);

	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	esi, DWORD PTR [eax+esi*2]
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax

; 364  : 		return (hi << 4) + lo - 0x110;

	lea	ecx, DWORD PTR [esi+edi*8]
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, -272				; fffffef0H
	pop	ebx

; 365  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?decode_lit@box_unbox@@IAEKK@Z ENDP			; box_unbox::decode_lit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?decode@box_unbox@@IAEKK@Z
_TEXT	SEGMENT
_xmid$1$ = -12						; size = 4
tv205 = -8						; size = 4
tv198 = -4						; size = 4
_cxt$ = 16						; size = 4
?decode@box_unbox@@IAEKK@Z PROC				; box_unbox::decode, COMDAT
; MDS probes
; _this$ = ecx

; 336  : 	__inline__ U32 decode(U32 cxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	push	160					; 000000a0H
	call	DWORD PTR __PogoRuntimeVector+16

; 337  : 		U32 p = ptbl[cxt]; // prediction in high 25 bits
; 338  : 		U32 xmid = x1 + ((x2 - x1) >> 12) * (p >> 20);

	mov	edx, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ebx+24]
	mov	DWORD PTR tv205[ebp], eax
	sub	edi, edx
	mov	eax, DWORD PTR _cxt$[ebp]
	shr	edi, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx+eax*4]
	shr	eax, 20					; 00000014H
	imul	edi, eax
	add	edi, edx
	mov	DWORD PTR _xmid$1$[ebp], edi

; 339  : 		U32 bit = (x <= xmid) ? 1 : 0;

	cmp	DWORD PTR [ebx+28], edi
	ja	SHORT $LN3@decode
	mov	esi, 1
	jmp	SHORT $LN4@decode
$LN3@decode:
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	xor	esi, esi
$LN4@decode:

; 340  : 		ptbl[cxt] += (bit << 25) - (p >> 7); // update prediction

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, esi
	mov	edi, DWORD PTR _cxt$[ebp]
	shl	ecx, 25					; 00000019H
	mov	edx, DWORD PTR [eax+edi*4]
	mov	eax, edx
	shr	eax, 7
	sub	ecx, eax
	mov	eax, DWORD PTR [ebx+16]
	add	ecx, edx
	mov	edx, edi
	mov	DWORD PTR [eax+edx*4], ecx

; 341  : 		*(bit ? &x2 : &x1) = xmid + (bit ? 0 : 1);

	test	esi, esi
	je	SHORT $LN7@decode
	xor	eax, eax
	jmp	SHORT $LN8@decode
$LN7@decode:
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	mov	eax, 1
$LN8@decode:
	lea	edx, DWORD PTR [ebx+24]
	test	esi, esi
	jne	SHORT $LN6@decode
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	mov	edx, DWORD PTR tv205[ebp]
$LN6@decode:
	mov	edi, DWORD PTR _xmid$1$[ebp]
	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR [edx], ecx

; 342  : 		//bit ? x2 = xmid : x1 = xmid + 1;
; 343  : 		_shift_in();

	mov	ecx, ebx
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_shift_in@box_unbox@@IAEXXZ		; box_unbox::_shift_in
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0

; 344  : 		return bit;

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 345  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?decode@box_unbox@@IAEKK@Z ENDP				; box_unbox::decode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?compress@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
_hash$1$ = -8						; size = 4
_smc$1$ = -4						; size = 4
?compress@box_mkbox@@IAEXXZ PROC			; box_mkbox::compress, COMDAT
; MDS probes
; _this$ = ecx

; 247  : 	__inline__ void compress() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	push	192					; 000000c0H
	call	DWORD PTR __PogoRuntimeVector+16

; 248  : 		x1 = 0; x2 = 0xFFFFFFFF;
; 249  : 		htbl = mem->htbl;

	mov	ecx, DWORD PTR [esi+8]

; 250  : 		ptbl = mem->ptbl;
; 251  : 
; 252  : 		fillmem(htbl, HASH_SIZE, (U32) 0);

	mov	edx, 262144				; 00040000H
	push	0
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [esi+20], 0
	lea	eax, DWORD PTR [ecx+1048576]
	mov	DWORD PTR [esi+24], -1
	push	121					; 00000079H
	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], eax
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 253  : 		fillmem(ptbl, SM_SIZE, (U32) 1 << 31);

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, 1056768				; 00102000H
	push	-2147483648				; 80000000H
	push	DWORD PTR [ebp+12]
	push	120					; 00000078H
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 254  : 		io_init();

	mov	eax, DWORD PTR [esi]
	add	esp, 8
	mov	ecx, esi
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [esi+4]
	push	119					; 00000077H
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf

; 255  : 
; 256  : 		U32 hash = 0, smc = 0, cxt = 0, chr;

	mov	DWORD PTR _hash$1$[ebp], 0
	xor	ebx, ebx
	mov	DWORD PTR _smc$1$[ebp], 0
	npad	3
$LL2@compress:

; 257  : 		while ((chr = _getchr()) <= 0xFF) {

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	116					; 00000074H
	call	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	mov	edi, eax
	cmp	edi, 255				; 000000ffH
	ja	$LN3@compress

; 258  : 			if (chr == (cxt & 0x0000FF)) {  // match first?

	movzx	edx, bl
	cmp	edi, edx
	jne	SHORT $LN4@compress

; 259  : 				cxt += (cxt < MATCH_MAX) ? MATCH_INC : 0;  // increment count

	cmp	ebx, 251658240				; 0f000000H
	jae	SHORT $LN11@compress
	mov	eax, 16777216				; 01000000H
	jmp	SHORT $LN12@compress
$LN11@compress:
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	xor	eax, eax
$LN12@compress:

; 260  : 				code_zero(smc);

	push	DWORD PTR _smc$1$[ebp]
	add	ebx, eax
	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	112					; 00000070H
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	pop	eax
	jmp	$LN9@compress
$LN4@compress:

; 261  : 			} else if ((chr << 8) == (cxt & 0x00FF00)) {  // match second?

	mov	ecx, ebx
	mov	eax, edi
	and	ecx, 65280				; 0000ff00H
	shl	eax, 8
	cmp	eax, ecx
	jne	$LN6@compress

; 262  : 				cxt = (cxt & 0xFF0000) | ((cxt << 8) & 0x00FF00) | chr | MATCH_INC;
; 263  : 				code_one(smc);

	push	DWORD PTR _smc$1$[ebp]
	or	edx, 65536				; 00010000H
	and	ebx, 16711680				; 00ff0000H
	shl	edx, 8
	mov	ecx, esi
	or	edx, ebx
	or	edx, edi
	mov	ebx, edx
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	96					; 00000060H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax

; 264  : 				code_one(smc + 1);

	mov	ecx, DWORD PTR _smc$1$[ebp]
	lea	eax, DWORD PTR [ecx+1]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	92					; 0000005cH
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax

; 265  : 				code_zero(smc + 2);

	mov	ecx, DWORD PTR _smc$1$[ebp]
	lea	eax, DWORD PTR [ecx+2]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	108					; 0000006cH
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax
	jmp	$LN9@compress
$LN6@compress:

; 266  : 			} else if ((chr << 16) == (cxt & 0xFF0000)) {  // match third?

	mov	ecx, ebx
	mov	eax, edi
	and	ecx, 16711680				; 00ff0000H
	shl	eax, 16					; 00000010H
	cmp	eax, ecx
	jne	SHORT $LN8@compress

; 267  : 				cxt = ((cxt << 8) & 0xFFFF00) | chr | MATCH_INC;
; 268  : 				code_one(smc);

	push	DWORD PTR _smc$1$[ebp]
	movzx	ebx, bx
	mov	ecx, esi
	or	ebx, 65536				; 00010000H
	shl	ebx, 8
	or	ebx, edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+80], 1
	adc	DWORD PTR [eax+84], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	88					; 00000058H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+88], 1
	adc	DWORD PTR [eax+92], 0
	pop	eax

; 269  : 				code_one(smc + 1);

	mov	ecx, DWORD PTR _smc$1$[ebp]
	lea	eax, DWORD PTR [ecx+1]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	84					; 00000054H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+96], 1
	adc	DWORD PTR [eax+100], 0
	pop	eax

; 270  : 				code_one(smc + 2);

	mov	ecx, DWORD PTR _smc$1$[ebp]
	lea	eax, DWORD PTR [ecx+2]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	80					; 00000050H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+104], 1
	adc	DWORD PTR [eax+108], 0
	pop	eax

; 271  : 			} else {  // literal?

	jmp	SHORT $LN9@compress
$LN8@compress:

; 272  : 				cxt = ((cxt << 8) & 0xFFFF00) | chr;
; 273  : 				code_one(smc);

	push	DWORD PTR _smc$1$[ebp]
	movzx	ebx, bx
	mov	ecx, esi
	shl	ebx, 8
	or	ebx, edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+112], 1
	adc	DWORD PTR [eax+116], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	76					; 0000004cH
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+120], 1
	adc	DWORD PTR [eax+124], 0
	pop	eax

; 274  : 				code_zero(smc + 1);

	mov	ecx, DWORD PTR _smc$1$[ebp]
	lea	eax, DWORD PTR [ecx+1]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	104					; 00000068H
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+128], 1
	adc	DWORD PTR [eax+132], 0
	pop	eax

; 275  : 				code_lit(smc + 2, chr);

	mov	eax, DWORD PTR _smc$1$[ebp]
	mov	ecx, esi
	push	edi
	add	eax, 2
	push	eax
	push	DWORD PTR [ebp+12]
	push	39					; 00000027H
	call	?code_lit@box_mkbox@@IAEXKK@Z		; box_mkbox::code_lit
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+136], 1
	adc	DWORD PTR [eax+140], 0
$LN9@compress:

; 276  : 			}
; 277  : 			htbl[hash] = cxt;

	mov	ecx, DWORD PTR _hash$1$[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+ecx*4], ebx

; 278  : 			hash = (((hash * 5) << HASH_SHIFT) + chr) & HASH_MASK;

	lea	ecx, DWORD PTR [ecx+ecx*4]

; 279  : 			cxt = htbl[hash];

	mov	ebx, DWORD PTR [esi+12]
	shl	ecx, 6
	add	ecx, edi

; 280  : 			smc = ((chr << 4) | (cxt >> 24)) * SM_PART;

	shl	edi, 4
	and	ecx, 262143				; 0003ffffH
	mov	DWORD PTR _hash$1$[ebp], ecx
	mov	ebx, DWORD PTR [ebx+ecx*4]
	mov	eax, ebx
	shr	eax, 24					; 00000018H
	or	eax, edi
	imul	eax, eax, 258
	mov	DWORD PTR _smc$1$[ebp], eax

; 281  : 		}

	jmp	$LL2@compress
$LN3@compress:

; 282  : 		// mark EOF by code first match as literal
; 283  : 		code_one(smc);

	mov	edi, DWORD PTR _smc$1$[ebp]
	mov	ecx, esi
	push	edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+144], 1
	adc	DWORD PTR [eax+148], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	72					; 00000048H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+152], 1
	adc	DWORD PTR [eax+156], 0
	pop	eax

; 284  : 		code_zero(smc + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	100					; 00000064H
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+160], 1
	adc	DWORD PTR [eax+164], 0
	pop	eax

; 285  : 		code_lit(smc + 2, cxt);

	push	ebx
	lea	eax, DWORD PTR [edi+2]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	6
	call	?code_lit@box_mkbox@@IAEXKK@Z		; box_mkbox::code_lit
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+168], 1
	adc	DWORD PTR [eax+172], 0
	pop	eax

; 286  : 		flush();

	movzx	eax, BYTE PTR [esi+23]
	mov	ecx, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	4
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr

; 287  : 		io_final();

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+176], 1
	adc	DWORD PTR [eax+180], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?io_final@box_io@@IAEXXZ		; box_io::io_final
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+184], 1
	adc	DWORD PTR [eax+188], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 288  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?compress@box_mkbox@@IAEXXZ ENDP			; box_mkbox::compress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?code_zero@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_cxt$ = 16						; size = 4
?code_zero@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_zero, COMDAT
; MDS probes
; _this$ = ecx

; 211  : 	__inline__ void code_zero(U32 cxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	push	144					; 00000090H
	call	DWORD PTR __PogoRuntimeVector+16

; 212  : 		U32 p = ptbl[cxt]; // prediction

	mov	edi, DWORD PTR [ecx+16]
	mov	esi, DWORD PTR _cxt$[ebp]

; 213  : 		ptbl[cxt] += (0 << 25) - (p >> 7); // update prediction
; 214  : 		x1 += ((x2 - x1) >> 12) * (p >> 20) + 1;
; 215  : 		_shift_out();

	push	DWORD PTR [ebp+12]
	push	1
	mov	ebx, DWORD PTR [edi+esi*4]
	mov	edx, ebx
	shr	edx, 7
	mov	eax, ebx
	sub	eax, edx
	shr	ebx, 20					; 00000014H
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [edi+esi*4], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, ecx
	inc	ecx
	shr	eax, 12					; 0000000cH
	imul	eax, ebx
	add	eax, ecx
	mov	ecx, edx
	mov	DWORD PTR [edx+20], eax
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 216  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?code_zero@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?code_one@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_cxt$ = 16						; size = 4
?code_one@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_one, COMDAT
; MDS probes
; _this$ = ecx

; 218  : 	__inline__ void code_one(U32 cxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	push	136					; 00000088H
	call	DWORD PTR __PogoRuntimeVector+16

; 219  : 		U32 p = ptbl[cxt]; // prediction

	mov	edi, DWORD PTR [ecx+16]
	mov	esi, DWORD PTR _cxt$[ebp]

; 220  : 		ptbl[cxt] += (1 << 25) - (p >> 7); // update prediction
; 221  : 		x2 = x1 + ((x2 - x1) >> 12) * (p >> 20);
; 222  : 		_shift_out();

	push	DWORD PTR [ebp+12]
	push	1
	mov	ebx, DWORD PTR [edi+esi*4]
	mov	eax, ebx
	shr	eax, 7
	mov	edx, ebx
	sub	edx, eax
	shr	ebx, 20					; 00000014H
	add	edx, 33554432				; 02000000H
	mov	DWORD PTR [edi+esi*4], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR [ecx+24]
	sub	ecx, eax
	shr	ecx, 12					; 0000000cH
	imul	ecx, ebx
	add	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, eax
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 223  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?code_one@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_one
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?code_lit@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_smc$ = 16						; size = 4
_chr$ = 20						; size = 4
?code_lit@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_lit, COMDAT
; MDS probes
; _this$ = ecx

; 230  : 	__inline__ void code_lit(U32 smc, U32 chr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	push	168					; 000000a8H
	call	DWORD PTR __PogoRuntimeVector+16

; 231  : 		// code high 4 bits in contexts cxt+1..15
; 232  : 		U32 block = ((chr & 0xFF) >> 4) | 16;

	mov	ebx, DWORD PTR _chr$[ebp]
	and	ebx, 240				; 000000f0H
	or	ebx, 256				; 00000100H
	shr	ebx, 4

; 233  : 		code(smc + 1, (block >> 3) & 1);

	mov	esi, ebx
	shr	esi, 3
	mov	eax, esi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	inc	eax
	push	eax
	push	DWORD PTR [ebp+12]
	push	29					; 0000001dH
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 234  : 		code(smc + (block >> 3), (block >> 2) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, ebx
	shr	edi, 2
	mov	eax, edi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	25					; 00000019H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 235  : 		code(smc + (block >> 2), (block >> 1) & 1);

	mov	esi, ebx
	shr	esi, 1
	mov	eax, esi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, edi
	mov	edi, DWORD PTR _this$1$[ebp]
	push	eax
	push	DWORD PTR [ebp+12]
	mov	ecx, edi
	push	21					; 00000015H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0

; 236  : 		code(smc + (block >> 1), block & 1);

	mov	eax, ebx
	and	eax, 1
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	17					; 00000011H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax

; 237  : 		// code low 4 bits in one of 16 blocks of 15 cxts (to reduce cache misses)
; 238  : 		smc += 15 * (block - 15);
; 239  : 		block = (chr & 15) | 16;

	mov	edi, DWORD PTR _chr$[ebp]
	lea	ecx, DWORD PTR [ebx-15]
	mov	ebx, DWORD PTR _smc$[ebp]
	mov	eax, ecx
	shl	eax, 4
	and	edi, 15					; 0000000fH
	or	edi, 16					; 00000010H
	sub	eax, ecx
	add	ebx, eax
	mov	DWORD PTR _chr$[ebp], edi

; 240  : 		code(smc + 1, (block >> 3) & 1);

	mov	esi, edi
	shr	esi, 3
	mov	eax, esi
	mov	ecx, DWORD PTR _this$1$[ebp]
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	DWORD PTR [ebp+12]
	push	13					; 0000000dH
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	pop	eax

; 241  : 		code(smc + (block >> 3), (block >> 2) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	shr	edi, 2
	mov	eax, edi
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	push	9
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax

; 242  : 		code(smc + (block >> 2), (block >> 1) & 1);

	mov	esi, DWORD PTR _chr$[ebp]
	shr	esi, 1
	mov	eax, esi
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _this$1$[ebp]
	push	eax
	push	DWORD PTR [ebp+12]
	mov	ecx, edi
	push	5
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0

; 243  : 		code(smc + (block >> 1), block & 1);

	mov	ecx, edi
	mov	eax, DWORD PTR _chr$[ebp]
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 244  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?code_lit@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_lit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?code@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
_cxt$ = 16						; size = 4
_bit$ = 20						; size = 4
?code@box_mkbox@@IAEXKK@Z PROC				; box_mkbox::code, COMDAT
; MDS probes
; _this$ = ecx

; 202  : 	__inline__ void code(U32 cxt, U32 bit) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	push	152					; 00000098H
	call	DWORD PTR __PogoRuntimeVector+16

; 203  : 		U32 p = ptbl[cxt]; // prediction

	mov	esi, DWORD PTR _cxt$[ebp]
	mov	edi, DWORD PTR [ebx+16]

; 204  : 		ptbl[cxt] += (bit << 25) - (p >> 7); // update prediction

	mov	edx, DWORD PTR _bit$[ebp]
	shl	edx, 25					; 00000019H
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	eax, ecx
	shr	eax, 7
	sub	edx, eax
	add	edx, ecx

; 205  : 		U32 xmid = x1 + ((x2 - x1) >> 12) * (p >> 20);

	shr	ecx, 20					; 00000014H
	mov	DWORD PTR [edi+esi*4], edx
	lea	esi, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [esi]
	sub	edx, eax
	shr	edx, 12					; 0000000cH
	imul	edx, ecx

; 206  : 		*(bit ? &x2 : &x1) = xmid + (bit ? 0 : 1);

	mov	ecx, DWORD PTR _bit$[ebp]
	add	edx, eax
	test	ecx, ecx
	je	SHORT $LN5@code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	xor	eax, eax
	jmp	SHORT $LN6@code
$LN5@code:
	mov	eax, 1
$LN6@code:
	test	ecx, ecx
	jne	SHORT $LN4@code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], ecx
	pop	eax
	lea	esi, DWORD PTR [ebx+20]
$LN4@code:
	add	eax, edx

; 207  : 		//bit ? x2 = xmid : x1 = xmid + 1;
; 208  : 		_shift_out();

	mov	ecx, ebx
	mov	DWORD PTR [esi], eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 209  : 	}

	pop	ebp
	ret	16					; 00000010H
?code@box_mkbox@@IAEXKK@Z ENDP				; box_mkbox::code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_shift_out@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?_shift_out@box_mkbox@@IAEXXZ PROC			; box_mkbox::_shift_out, COMDAT
; MDS probes
; _this$ = ecx

; 185  : 	__inline__ void _shift_out() {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	112					; 00000070H
	call	DWORD PTR __PogoRuntimeVector+16

; 186  : 		if ((x1 ^ x2) > 0x00FFFFFF) {

	mov	eax, DWORD PTR [esi+20]
	xor	eax, DWORD PTR [esi+24]
	cmp	eax, 16777215				; 00ffffffH
	ja	SHORT $LN10@shift_out
	npad	5
$LL4@shift_out:

; 187  : 		} else {
; 188  : 			do {  // pass equal leading bytes of range
; 189  : 				_putchr(x1 >> 24);

	movzx	eax, BYTE PTR [esi+23]
	mov	ecx, esi
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 190  : 				x1 <<= 8;
; 191  : 				x2 = (x2 << 8) | 0xFF;

	mov	eax, DWORD PTR [esi+24]
	shl	DWORD PTR [esi+20], 8
	shl	eax, 8
	or	eax, 255				; 000000ffH
	mov	DWORD PTR [esi+24], eax

; 192  : 			} while ((x1 ^ x2) <= 0x00FFFFFF);

	xor	eax, DWORD PTR [esi+20]
	cmp	eax, 16777215				; 00ffffffH
	jbe	SHORT $LL4@shift_out

; 186  : 		if ((x1 ^ x2) > 0x00FFFFFF) {

	jmp	SHORT $LN3@shift_out
$LN10@shift_out:
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
$LN3@shift_out:
	pop	esi

; 193  : 		}
; 194  : 	}

	pop	ebp
	ret	8
?_shift_out@box_mkbox@@IAEXXZ ENDP			; box_mkbox::_shift_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_shift_in@box_unbox@@IAEXXZ
_TEXT	SEGMENT
tv90 = -8						; size = 4
tv89 = -4						; size = 4
?_shift_in@box_unbox@@IAEXXZ PROC			; box_unbox::_shift_in, COMDAT
; MDS probes
; _this$ = ecx

; 320  : 	__inline__ void _shift_in() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	128					; 00000080H
	call	DWORD PTR __PogoRuntimeVector+16

; 321  : 		while ((x1 ^ x2) <= 0x00FFFFFF) {  // pass equal leading bytes of range

	mov	DWORD PTR tv89[ebp], 32			; 00000020H
	npad	5
$LL2@shift_in:
	mov	edx, DWORD PTR [esi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+24]
	xor	eax, ecx
	cmp	eax, 16777215				; 00ffffffH
	ja	SHORT $LN3@shift_in

; 322  : 			x1 <<= 8;
; 323  : 			x2 = (x2 << 8) | 0xFF;

	shl	ecx, 8
	or	ecx, 255				; 000000ffH
	shl	edx, 8
	mov	DWORD PTR [esi+24], ecx

; 324  : 			x = (x << 8) | (_getchr() & 0xFF);

	mov	ecx, esi
	mov	DWORD PTR tv89[ebp], 24			; 00000018H
	mov	DWORD PTR [esi+20], edx
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	movzx	ecx, al
	mov	eax, DWORD PTR [esi+28]
	shl	eax, 8
	or	eax, ecx
	mov	DWORD PTR [esi+28], eax

; 325  : 		}

	jmp	SHORT $LL2@shift_in
$LN3@shift_in:

; 321  : 		while ((x1 ^ x2) <= 0x00FFFFFF) {  // pass equal leading bytes of range

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv89[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	pop	esi

; 326  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?_shift_in@box_unbox@@IAEXXZ ENDP			; box_unbox::_shift_in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_putchr@box_io@@IAEXK@Z
_TEXT	SEGMENT
_chr$ = 16						; size = 4
?_putchr@box_io@@IAEXK@Z PROC				; box_io::_putchr, COMDAT
; MDS probes
; _this$ = ecx

; 134  : 	__inline__ void _putchr(U32 chr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	64					; 00000040H
	call	DWORD PTR __PogoRuntimeVector+16

; 135  : 		if (output->count < output->size) { // is buffer not empty?

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [edx+12]
	jge	SHORT $LN2@putchr

; 136  : 			output->buffer[output->count++] = (U8) chr; // put chr to buffer

	mov	edx, DWORD PTR [edx+8]
	mov	al, BYTE PTR _chr$[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, DWORD PTR [esi+4]
	inc	DWORD PTR [eax+16]

; 137  : 		} else {

	jmp	SHORT $LN4@putchr
$LN2@putchr:

; 138  : 			_flushbuf(); // flush output buffer

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0

; 139  : 			if (output->size > 0) {

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN4@putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 140  : 				output->count = 0; // reset count

	mov	DWORD PTR [eax+16], 0

; 141  : 				output->buffer[output->count++] = (U8) chr; // put chr to buffer

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+8]
	mov	al, BYTE PTR _chr$[ebp]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, DWORD PTR [esi+4]
	inc	DWORD PTR [eax+16]
$LN4@putchr:
	pop	esi

; 142  : 			} else {
; 143  : 				// well, dead end here, we lost a chr
; 144  : 			}
; 145  : 		}
; 146  : 	}

	pop	ebp
	ret	12					; 0000000cH
?_putchr@box_io@@IAEXK@Z ENDP				; box_io::_putchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_getchr@box_io@@IAEKXZ
_TEXT	SEGMENT
?_getchr@box_io@@IAEKXZ PROC				; box_io::_getchr, COMDAT
; MDS probes
; _this$ = ecx

; 119  : 	__inline__ U32 _getchr() {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	88					; 00000058H
	call	DWORD PTR __PogoRuntimeVector+16

; 120  : 		if (input->count < input->size) { // is buffer not empty?

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [edx+12]
	jge	SHORT $LN2@getchr

; 121  : 			return (U32) input->buffer[input->count++]; // get chr from buffer

	mov	eax, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [eax+ecx]
	inc	ecx
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN5@getchr
$LN2@getchr:

; 122  : 		} else {
; 123  : 			_fillbuf(); // fill input buffer

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0

; 124  : 			if (input->size > 0) {

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN4@getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 125  : 				input->count = 0; // reset count

	mov	DWORD PTR [eax+16], 0

; 126  : 				return (U32) input->buffer[input->count++]; // get chr from buffer

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [eax+ecx]
	inc	ecx
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN5@getchr
$LN4@getchr:

; 127  : 			} else {
; 128  : 				return (U32) 0xFFFFFFFF; // end of input

	or	eax, -1
$LN5@getchr:
	pop	esi

; 129  : 			}
; 130  : 		}
; 131  : 	}

	pop	ebp
	ret	8
?_getchr@box_io@@IAEKXZ ENDP				; box_io::_getchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_flushbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_flushbuf@box_io@@IAEXXZ PROC				; box_io::_flushbuf, COMDAT
; MDS probes
; _this$ = ecx

; 114  : 	__inline__ void _flushbuf() {

	push	ebp
	mov	ebp, esp
	push	24					; 00000018H
	call	DWORD PTR __PogoRuntimeVector+16

; 115  : 		(*output->callback)(output);

	mov	eax, DWORD PTR [ecx+4]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+28
	call	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	add	esp, 4

; 116  : 	}

	pop	ebp
	ret	8
?_flushbuf@box_io@@IAEXXZ ENDP				; box_io::_flushbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?_fillbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_fillbuf@box_io@@IAEXXZ PROC				; box_io::_fillbuf, COMDAT
; MDS probes
; _this$ = ecx

; 109  : 	__inline__ void _fillbuf() {

	push	ebp
	mov	ebp, esp
	push	32					; 00000020H
	call	DWORD PTR __PogoRuntimeVector+16

; 110  : 		(*input->callback)(input);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+28
	call	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	add	esp, 4

; 111  : 	}

	pop	ebp
	ret	8
?_fillbuf@box_io@@IAEXXZ ENDP				; box_io::_fillbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
__input$ = 16						; size = 4
__output$ = 20						; size = 4
__mem$ = 24						; size = 4
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_unbox::box_unbox, COMDAT
; MDS probes
; _this$ = ecx

; 410  : 	__inline__ box_unbox(

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	200					; 000000c8H
	call	DWORD PTR __PogoRuntimeVector+16

; 411  : 		BOX_CALLBACK_STRUCT *_input, // input
; 412  : 		BOX_CALLBACK_STRUCT *_output, // output
; 413  : 		BOX_WORKMEM *_mem // workmem
; 414  : 	) : box_io(_input, _output), mem(_mem) {

	mov	eax, DWORD PTR __input$[ebp]

; 415  : 		decompress();

	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __output$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __mem$[ebp]
	push	1
	mov	DWORD PTR [esi+8], eax
	call	?decompress@box_unbox@@IAEXXZ		; box_unbox::decompress
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0

; 416  : 	}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	20					; 00000014H
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_unbox::box_unbox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
__input$ = 16						; size = 4
__output$ = 20						; size = 4
__mem$ = 24						; size = 4
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_mkbox::box_mkbox, COMDAT
; MDS probes
; _this$ = ecx

; 292  : 	__inline__ box_mkbox(

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	216					; 000000d8H
	call	DWORD PTR __PogoRuntimeVector+16

; 293  : 		BOX_CALLBACK_STRUCT *_input, // input
; 294  : 		BOX_CALLBACK_STRUCT *_output, // output
; 295  : 		BOX_WORKMEM *_mem // workmem
; 296  : 	) : box_io(_input, _output), mem(_mem) {

	mov	eax, DWORD PTR __input$[ebp]

; 297  : 		compress();

	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __output$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __mem$[ebp]
	push	1
	mov	DWORD PTR [esi+8], eax
	call	?compress@box_mkbox@@IAEXXZ		; box_mkbox::compress
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0

; 298  : 	}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	20					; 00000014H
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_mkbox::box_mkbox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ??$fillmem@K@@YAXPAKHK@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
tv70 = -4						; size = 4
_fill$ = 16						; size = 4
??$fillmem@K@@YAXPAKHK@Z PROC				; fillmem<unsigned long>, COMDAT
; MDS probes
; _pointer$ = ecx
; _size$ = edx

; 92   : static __inline__ void fillmem(type *pointer, int size, type fill) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+16

; 93   : 	for (int i = 0; i < size; i++) {

	mov	esi, DWORD PTR _fill$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv70[ebp], 32			; 00000020H
	mov	DWORD PTR tv71[ebp], 16			; 00000010H
$LL4@fillmem:
	cmp	eax, edx
	jge	SHORT $LN3@fillmem
	mov	DWORD PTR tv70[ebp], 24			; 00000018H
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv71[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	mov	DWORD PTR tv71[ebp], 8

; 94   : 		pointer[i] = fill;

	mov	DWORD PTR [ecx+eax*4], esi
	inc	eax
	jmp	SHORT $LL4@fillmem
$LN3@fillmem:

; 93   : 	for (int i = 0; i < size; i++) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv70[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	pop	esi

; 95   : 	}
; 96   : }

	mov	esp, ebp
	pop	ebp
	mov	ecx, DWORD PTR [esp]
	mov	DWORD PTR [esp+8], ecx
	add	esp, 8
	ret	0
??$fillmem@K@@YAXPAKHK@Z ENDP				; fillmem<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
; Plain probes

; 85   :     {

	call	DWORD PTR __PogoRuntimeVector+12
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__vfprintf_l PROC					; COMDAT
; External Pogo thunk for __vfprintf_l
	pop	eax
	push	667					; 0000029bH
	push	0
	push	eax
	jmp	__vfprintf_l
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT
; Plain probes

; 952  :     {

	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);
; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax
	mov	edx, DWORD PTR __Format$[esp+8]
	add	esp, 4
	mov	ecx, eax
	push	627					; 00000273H
	push	1
	call	__vfprintf_l
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax
	add	esp, 8

; 957  :         __crt_va_end(_ArgList);
; 958  :         return _Result;
; 959  :     }

	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_fillbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_fillbuf@box_io@@IAEXXZ PROC				; box_io::_fillbuf, COMDAT
; External Pogo thunk for ?_fillbuf@box_io@@IAEXXZ
	pop	eax
	push	658					; 00000292H
	push	0
	push	eax
	jmp	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
?_fillbuf@box_io@@IAEXXZ ENDP				; box_io::_fillbuf
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_flushbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_flushbuf@box_io@@IAEXXZ PROC				; box_io::_flushbuf, COMDAT
; External Pogo thunk for ?_flushbuf@box_io@@IAEXXZ
	pop	eax
	push	657					; 00000291H
	push	0
	push	eax
	jmp	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
?_flushbuf@box_io@@IAEXXZ ENDP				; box_io::_flushbuf
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_getchr@box_io@@IAEKXZ
_TEXT	SEGMENT
?_getchr@box_io@@IAEKXZ PROC				; box_io::_getchr, COMDAT
; External Pogo thunk for ?_getchr@box_io@@IAEKXZ
	pop	eax
	push	665					; 00000299H
	push	0
	push	eax
	jmp	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
?_getchr@box_io@@IAEKXZ ENDP				; box_io::_getchr
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_putchr@box_io@@IAEXK@Z
_TEXT	SEGMENT
?_putchr@box_io@@IAEXK@Z PROC				; box_io::_putchr, COMDAT
; External Pogo thunk for ?_putchr@box_io@@IAEXK@Z
	pop	eax
	push	663					; 00000297H
	push	0
	push	eax
	jmp	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
?_putchr@box_io@@IAEXK@Z ENDP				; box_io::_putchr
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?io_init@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_init@box_io@@IAEXXZ PROC				; box_io::io_init, COMDAT
; External Pogo thunk for ?io_init@box_io@@IAEXXZ
	pop	eax
	push	661					; 00000295H
	push	0
	push	eax
	jmp	?io_init@box_io@@IAEXXZ			; box_io::io_init
?io_init@box_io@@IAEXXZ ENDP				; box_io::io_init
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?io_final@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_final@box_io@@IAEXXZ PROC				; box_io::io_final, COMDAT
; External Pogo thunk for ?io_final@box_io@@IAEXXZ
	pop	eax
	push	659					; 00000293H
	push	0
	push	eax
	jmp	?io_final@box_io@@IAEXXZ		; box_io::io_final
?io_final@box_io@@IAEXXZ ENDP				; box_io::io_final
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z
_TEXT	SEGMENT
__input$ = 8						; size = 4
__output$ = 12						; size = 4
??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z PROC	; box_io::box_io, COMDAT
; _this$ = ecx

; 163  : 		BOX_CALLBACK_STRUCT *_input, // input
; 164  : 		BOX_CALLBACK_STRUCT *_output // output
; 165  : 	) : input(_input), output(_output) {}

	mov	eax, DWORD PTR __input$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __output$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z ENDP	; box_io::box_io
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_shift_out@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?_shift_out@box_mkbox@@IAEXXZ PROC			; box_mkbox::_shift_out, COMDAT
; External Pogo thunk for ?_shift_out@box_mkbox@@IAEXXZ
	pop	eax
	push	677					; 000002a5H
	push	0
	push	eax
	jmp	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
?_shift_out@box_mkbox@@IAEXXZ ENDP			; box_mkbox::_shift_out
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?flush@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?flush@box_mkbox@@IAEXXZ PROC				; box_mkbox::flush, COMDAT
; External Pogo thunk for ?flush@box_mkbox@@IAEXXZ
	pop	eax
	push	674					; 000002a2H
	push	0
	push	eax
	jmp	?flush@box_mkbox@@IAEXXZ		; box_mkbox::flush
?flush@box_mkbox@@IAEXXZ ENDP				; box_mkbox::flush
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
?code@box_mkbox@@IAEXKK@Z PROC				; box_mkbox::code, COMDAT
; External Pogo thunk for ?code@box_mkbox@@IAEXKK@Z
	pop	eax
	push	692					; 000002b4H
	push	0
	push	eax
	jmp	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
?code@box_mkbox@@IAEXKK@Z ENDP				; box_mkbox::code
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_zero@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
?code_zero@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_zero, COMDAT
; External Pogo thunk for ?code_zero@box_mkbox@@IAEXK@Z
	pop	eax
	push	688					; 000002b0H
	push	0
	push	eax
	jmp	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
?code_zero@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_zero
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_one@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
?code_one@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_one, COMDAT
; External Pogo thunk for ?code_one@box_mkbox@@IAEXK@Z
	pop	eax
	push	684					; 000002acH
	push	0
	push	eax
	jmp	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
?code_one@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_one
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_lit@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
?code_lit@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_lit, COMDAT
; External Pogo thunk for ?code_lit@box_mkbox@@IAEXKK@Z
	pop	eax
	push	729					; 000002d9H
	push	0
	push	eax
	jmp	?code_lit@box_mkbox@@IAEXKK@Z		; box_mkbox::code_lit
?code_lit@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_lit
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?compress@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?compress@box_mkbox@@IAEXXZ PROC			; box_mkbox::compress, COMDAT
; External Pogo thunk for ?compress@box_mkbox@@IAEXXZ
	pop	eax
	push	819					; 00000333H
	push	0
	push	eax
	jmp	?compress@box_mkbox@@IAEXXZ		; box_mkbox::compress
?compress@box_mkbox@@IAEXXZ ENDP			; box_mkbox::compress
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_mkbox::box_mkbox, COMDAT
; External Pogo thunk for ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
	pop	eax
	push	999					; 000003e7H
	push	0
	push	eax
	jmp	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_mkbox::box_mkbox
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_shift_in@box_unbox@@IAEXXZ
_TEXT	SEGMENT
?_shift_in@box_unbox@@IAEXXZ PROC			; box_unbox::_shift_in, COMDAT
; External Pogo thunk for ?_shift_in@box_unbox@@IAEXXZ
	pop	eax
	push	671					; 0000029fH
	push	0
	push	eax
	jmp	?_shift_in@box_unbox@@IAEXXZ		; box_unbox::_shift_in
?_shift_in@box_unbox@@IAEXXZ ENDP			; box_unbox::_shift_in
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?fill_x@box_unbox@@IAEXXZ
_TEXT	SEGMENT
?fill_x@box_unbox@@IAEXXZ PROC				; box_unbox::fill_x, COMDAT
; External Pogo thunk for ?fill_x@box_unbox@@IAEXXZ
	pop	eax
	push	668					; 0000029cH
	push	0
	push	eax
	jmp	?fill_x@box_unbox@@IAEXXZ		; box_unbox::fill_x
?fill_x@box_unbox@@IAEXXZ ENDP				; box_unbox::fill_x
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?decode@box_unbox@@IAEKK@Z
_TEXT	SEGMENT
?decode@box_unbox@@IAEKK@Z PROC				; box_unbox::decode, COMDAT
; External Pogo thunk for ?decode@box_unbox@@IAEKK@Z
	pop	eax
	push	680					; 000002a8H
	push	0
	push	eax
	jmp	?decode@box_unbox@@IAEKK@Z		; box_unbox::decode
?decode@box_unbox@@IAEKK@Z ENDP				; box_unbox::decode
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?decode_lit@box_unbox@@IAEKK@Z
_TEXT	SEGMENT
?decode_lit@box_unbox@@IAEKK@Z PROC			; box_unbox::decode_lit, COMDAT
; External Pogo thunk for ?decode_lit@box_unbox@@IAEKK@Z
	pop	eax
	push	696					; 000002b8H
	push	0
	push	eax
	jmp	?decode_lit@box_unbox@@IAEKK@Z		; box_unbox::decode_lit
?decode_lit@box_unbox@@IAEKK@Z ENDP			; box_unbox::decode_lit
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?decompress@box_unbox@@IAEXXZ
_TEXT	SEGMENT
?decompress@box_unbox@@IAEXXZ PROC			; box_unbox::decompress, COMDAT
; External Pogo thunk for ?decompress@box_unbox@@IAEXXZ
	pop	eax
	push	762					; 000002faH
	push	0
	push	eax
	jmp	?decompress@box_unbox@@IAEXXZ		; box_unbox::decompress
?decompress@box_unbox@@IAEXXZ ENDP			; box_unbox::decompress
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_unbox::box_unbox, COMDAT
; External Pogo thunk for ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
	pop	eax
	push	941					; 000003adH
	push	0
	push	eax
	jmp	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_unbox::box_unbox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?box_workmem_size@@YAKXZ
_TEXT	SEGMENT
?box_workmem_size@@YAKXZ PROC				; box_workmem_size, COMDAT

; 423  : 	return sizeof(BOX_WORKMEM);

	mov	eax, 5275648				; 00508000H

; 424  : }

	ret	0
?box_workmem_size@@YAKXZ ENDP				; box_workmem_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z
_TEXT	SEGMENT
_mkbox$ = -28						; size = 28
__mem$ = 8						; size = 4
?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z PROC	; box_compress, COMDAT
; Plain probes
; __input$ = ecx
; __output$ = edx

; 430  : ) {

	sub	esp, 28					; 0000001cH
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+88], 1
	adc	DWORD PTR [eax+92], 0
	pop	eax

; 431  : 	box_mkbox mkbox(_input, _output, (BOX_WORKMEM*) _mem);

	push	DWORD PTR __mem$[esp+24]
	push	edx
	push	ecx
	push	2
	lea	ecx, DWORD PTR _mkbox$[esp+44]
	push	1
	call	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+96], 1
	adc	DWORD PTR [eax+100], 0
	pop	eax

; 432  : }

	add	esp, 28					; 0000001cH
	ret	0
?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ENDP	; box_compress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\boxbox.h
;	COMDAT ?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z
_TEXT	SEGMENT
_unbox$ = -32						; size = 32
__mem$ = 8						; size = 4
?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z PROC ; box_decompress, COMDAT
; Plain probes
; __input$ = ecx
; __output$ = edx

; 438  : ) {

	sub	esp, 32					; 00000020H
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax

; 439  : 	box_unbox unbox(_input, _output, (BOX_WORKMEM*) _mem);

	push	DWORD PTR __mem$[esp+28]
	push	edx
	push	ecx
	push	126					; 0000007eH
	lea	ecx, DWORD PTR _unbox$[esp+48]
	push	1
	call	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+80], 1
	adc	DWORD PTR [eax+84], 0
	pop	eax

; 440  : }

	add	esp, 32					; 00000020H
	ret	0
?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ENDP ; box_decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT ?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z PROC	; input_proc, COMDAT
; Plain probes

; 10   : void __cdecl input_proc(BOX_CALLBACK_STRUCT *input) {

	push	esi
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 11   : 	input->size = fread(input->buffer, sizeof(char), input->size, (FILE*) input->handle);

	mov	esi, DWORD PTR _input$[esp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+12]
	push	1
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__fread
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 12   : }

	ret	0
?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ENDP	; input_proc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT ?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
_TEXT	SEGMENT
_output$ = 8						; size = 4
?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z PROC	; output_proc, COMDAT
; Plain probes

; 14   : void __cdecl output_proc(BOX_CALLBACK_STRUCT *output) {

	call	DWORD PTR __PogoRuntimeVector+12
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0

; 15   : 	fwrite(output->buffer, sizeof(char), output->count, (FILE*) output->handle);

	mov	eax, DWORD PTR _output$[esp-4]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax+16]
	push	1
	push	DWORD PTR [eax+8]
	call	DWORD PTR __imp__fwrite
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	add	esp, 16					; 00000010H

; 16   : }

	ret	0
?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ENDP	; output_proc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_in$1$ = -52						; size = 4
_inbuf$1$ = -48						; size = 4
_start$1$ = -44						; size = 4
_output$ = -40						; size = 20
_input$ = -20						; size = 20
_outbuf$1$ = 8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT
; Plain probes

; 19   : int main(int argc, char **argv) {

	sub	esp, 52					; 00000034H
	push	edi
	call	___PogoPushAllXmm@0
	call	DWORD PTR __PogoRuntimeVector+12
	call	___PogoPopAllXmm@0
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+104], 1
	adc	DWORD PTR [eax+108], 0
	pop	eax

; 20   : 
; 21   : 	// Check arguments
; 22   : 	if ((argc != 4) || ((argv[1][0] != 'c') && (argv[1][0] != 'd'))) {

	cmp	DWORD PTR _argc$[esp+52], 4
	jne	$LN3@main
	mov	edi, DWORD PTR _argv$[esp+52]
	mov	eax, DWORD PTR [edi+4]
	mov	al, BYTE PTR [eax]
	cmp	al, 99					; 00000063H
	je	SHORT $LN2@main
	cmp	al, 100					; 00000064H
	jne	$LN12@main
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+112], 1
	adc	DWORD PTR [eax+116], 0
	pop	eax
$LN2@main:

; 25   : 	}
; 26   : 
; 27   : 	// Get start time
; 28   : 	clock_t start = clock();

	push	esi
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+120], 1
	adc	DWORD PTR [eax+124], 0
	call	DWORD PTR __imp__clock
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+128], 1
	adc	DWORD PTR [eax+132], 0
	pop	eax

; 29   : 
; 30   : 	// Compress
; 31   : 	FILE *in = fopen(argv[2], "rb");

	mov	esi, DWORD PTR __imp__fopen
	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	DWORD PTR [edi+8]
	mov	DWORD PTR _start$1$[esp+68], eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+136], 1
	adc	DWORD PTR [eax+140], 0
	pop	eax
	add	esp, 8
	mov	DWORD PTR _in$1$[esp+60], eax

; 32   : 	if (!in) perror(argv[2]), exit(1);

	test	eax, eax
	jne	SHORT $LN4@main
	push	DWORD PTR [edi+8]
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+144], 1
	adc	DWORD PTR [eax+148], 0
	pop	eax
	call	DWORD PTR __imp__perror
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+152], 1
	adc	DWORD PTR [eax+156], 0
	pop	eax
	add	esp, 4
	push	1
	call	DWORD PTR __imp__exit
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+160], 1
	adc	DWORD PTR [eax+164], 0
	pop	eax
$LN13@main:
$LN4@main:
	push	ebp

; 33   : 	FILE *out = fopen(argv[3], "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	DWORD PTR [edi+12]
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+168], 1
	adc	DWORD PTR [eax+172], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+176], 1
	adc	DWORD PTR [eax+180], 0
	pop	eax
	mov	ebp, eax
	add	esp, 8

; 34   : 	if (!out) perror(argv[3]), exit(1);

	test	ebp, ebp
	jne	SHORT $LN5@main
	push	DWORD PTR [edi+12]
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+184], 1
	adc	DWORD PTR [eax+188], ebp
	pop	eax
	call	DWORD PTR __imp__perror
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+192], 1
	adc	DWORD PTR [eax+196], ebp
	pop	eax
	add	esp, 4
	push	1
	call	DWORD PTR __imp__exit
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+200], 1
	adc	DWORD PTR [eax+204], ebp
	pop	eax
$LN14@main:
$LN5@main:

; 35   : 
; 36   : 	unsigned char *inbuf = (unsigned char *) malloc(1 << 20);

	mov	esi, DWORD PTR __imp__malloc
	push	ebx
	push	1048576					; 00100000H
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+208], 1
	adc	DWORD PTR [eax+212], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+216], 1
	adc	DWORD PTR [eax+220], 0
	pop	eax

; 37   : 	unsigned char *outbuf = (unsigned char *) malloc(1 << 20);

	push	1048576					; 00100000H
	mov	DWORD PTR _inbuf$1$[esp+76], eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+224], 1
	adc	DWORD PTR [eax+228], 0
	pop	eax
	mov	DWORD PTR _outbuf$1$[esp+72], eax

; 38   : 	void *mem = malloc(box_workmem_size());

	call	?box_workmem_size@@YAKXZ		; box_workmem_size
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+232], 1
	adc	DWORD PTR [eax+236], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+240], 1
	adc	DWORD PTR [eax+244], 0
	pop	eax

; 39   : 
; 40   : 	BOX_CALLBACK_STRUCT input;
; 41   : 	input.callback = &input_proc;
; 42   : 	input.handle = (void*) in;
; 43   : 	input.buffer = inbuf;
; 44   : 	input.size = 1 << 20;
; 45   : 
; 46   : 	BOX_CALLBACK_STRUCT output;
; 47   : 	output.callback = &output_proc;
; 48   : 	output.handle = (void*) out;
; 49   : 	output.buffer = outbuf;
; 50   : 	output.size = 1 << 20;
; 51   : 
; 52   : 	if (argv[1][0] == 'c') {

	mov	ecx, DWORD PTR [edi+4]
	mov	ebx, eax
	mov	eax, DWORD PTR _in$1$[esp+80]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _inbuf$1$[esp+68]
	mov	DWORD PTR _input$[esp+72], eax
	mov	eax, DWORD PTR _outbuf$1$[esp+64]
	mov	DWORD PTR _input$[esp+68], OFFSET ?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ; input_proc
	mov	DWORD PTR _input$[esp+76], esi
	mov	DWORD PTR _input$[esp+80], 1048576	; 00100000H
	mov	DWORD PTR _output$[esp+68], OFFSET ?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ; output_proc
	mov	DWORD PTR _output$[esp+72], ebp
	mov	DWORD PTR _output$[esp+76], eax
	mov	DWORD PTR _output$[esp+80], 1048576	; 00100000H
	cmp	BYTE PTR [ecx], 99			; 00000063H
	jne	SHORT $LN6@main

; 53   : 		box_compress(&input, &output, mem);

	push	ebx
	lea	edx, DWORD PTR _output$[esp+72]
	lea	ecx, DWORD PTR _input$[esp+72]
	call	?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_compress
	add	esp, 4

; 54   : 	} else {

	jmp	SHORT $LN7@main
$LN6@main:

; 39   : 
; 40   : 	BOX_CALLBACK_STRUCT input;
; 41   : 	input.callback = &input_proc;
; 42   : 	input.handle = (void*) in;
; 43   : 	input.buffer = inbuf;
; 44   : 	input.size = 1 << 20;
; 45   : 
; 46   : 	BOX_CALLBACK_STRUCT output;
; 47   : 	output.callback = &output_proc;
; 48   : 	output.handle = (void*) out;
; 49   : 	output.buffer = outbuf;
; 50   : 	output.size = 1 << 20;
; 51   : 
; 52   : 	if (argv[1][0] == 'c') {

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+248], 1
	adc	DWORD PTR [eax+252], 0
	pop	eax

; 55   : 		box_decompress(&input, &output, mem);

	push	ebx
	lea	edx, DWORD PTR _output$[esp+72]
	lea	ecx, DWORD PTR _input$[esp+72]
	call	?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_decompress
	add	esp, 4
$LN7@main:

; 56   : 	}
; 57   : 
; 58   : 	free(inbuf);

	push	esi
	mov	esi, DWORD PTR __imp__free
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+256], 1
	adc	DWORD PTR [eax+260], 0
	pop	eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+264], 1
	adc	DWORD PTR [eax+268], 0
	pop	eax

; 59   : 	free(outbuf);

	push	DWORD PTR _outbuf$1$[esp+68]
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+272], 1
	adc	DWORD PTR [eax+276], 0
	pop	eax

; 60   : 	free(mem);

	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+280], 1
	adc	DWORD PTR [eax+284], 0
	pop	eax

; 61   : 
; 62   : 	// Report result
; 63   : 	printf("%ld -> %ld in %1.2f sec.\n",

	call	DWORD PTR __imp__clock
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+288], 1
	adc	DWORD PTR [eax+292], 0
	pop	eax
	sub	eax, DWORD PTR _start$1$[esp+80]
	add	esp, 4
	mov	esi, DWORD PTR __imp__ftell
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR [esp], xmm0
	push	ebp
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+296], 1
	adc	DWORD PTR [eax+300], 0
	pop	eax
	mov	ebx, DWORD PTR _in$1$[esp+80]
	add	esp, 4
	push	eax
	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+304], 1
	adc	DWORD PTR [eax+308], 0
	pop	eax
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@
	call	_printf
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+312], 1
	adc	DWORD PTR [eax+316], 0
	pop	eax

; 64   : 		ftell(in), ftell(out), double(clock() - start) / CLOCKS_PER_SEC);
; 65   : 
; 66   : 	fclose(in);

	mov	esi, DWORD PTR __imp__fclose
	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+320], 1
	adc	DWORD PTR [eax+324], 0
	pop	eax

; 67   : 	fclose(out);

	push	ebp
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+328], 1
	adc	DWORD PTR [eax+332], 0
	pop	eax
	add	esp, 28					; 0000001cH

; 68   : 	return 0;

	xor	eax, eax
	pop	ebx
	jmp	SHORT $LN10@main
$LN12@main:

; 20   : 
; 21   : 	// Check arguments
; 22   : 	if ((argc != 4) || ((argv[1][0] != 'c') && (argv[1][0] != 'd'))) {

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+336], 1
	adc	DWORD PTR [eax+340], 0
	pop	eax
$LN3@main:

; 23   : 		printf("<exe> c/d <input> <output>\n");

	push	OFFSET ??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+344], 1
	adc	DWORD PTR [eax+348], 0
	pop	eax
	call	_printf
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+352], 1
	adc	DWORD PTR [eax+356], 0
	pop	eax
	add	esp, 4

; 24   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@main
$LN10@main:
	pop	ebp
	pop	esi
$LN1@main:
	pop	edi

; 69   : }

	add	esp, 52					; 00000034H
	ret	0
$LN11@main:
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??$fillmem@K@@YAXPAKHK@Z
_TEXT	SEGMENT
??$fillmem@K@@YAXPAKHK@Z PROC				; fillmem<unsigned long>, COMDAT
; External Pogo thunk for ??$fillmem@K@@YAXPAKHK@Z
	pop	eax
	push	656					; 00000290H
	push	0
	push	eax
	jmp	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>
??$fillmem@K@@YAXPAKHK@Z ENDP				; fillmem<unsigned long>
_TEXT	ENDS
END
