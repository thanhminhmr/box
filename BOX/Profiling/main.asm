; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25508.2 

	TITLE	d:\___x\hack\appupdt\box\box\box\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@ ; `string'
EXTRN	__imp__malloc:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__perror:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__clock:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__ftell:PROC
;	COMDAT ??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@ DB '%'
	DB	'ld -> %ld in %1.2f sec.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@
CONST	SEGMENT
??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@ DB '<'
	DB	'exe> c/d <input> <output>', 0aH, 00H	; `string'
CONST	ENDS
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_main
PUBLIC	?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z	; output_proc
PUBLIC	?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z	; input_proc
PUBLIC	?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_decompress
PUBLIC	?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_compress
PUBLIC	?box_workmem_size@@YAKXZ			; box_workmem_size
PUBLIC	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
PUBLIC	?decompress@box_unbox@@IAEXXZ			; box_unbox::decompress
PUBLIC	?fill_x@box_unbox@@IAEXXZ			; box_unbox::fill_x
PUBLIC	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
PUBLIC	?compress@box_mkbox@@IAEXXZ			; box_mkbox::compress
PUBLIC	?code_match@box_mkbox@@IAEXKK@Z			; box_mkbox::code_match
PUBLIC	?code_lit@box_mkbox@@IAEXKK@Z			; box_mkbox::code_lit
PUBLIC	?code_one@box_mkbox@@IAEXK@Z			; box_mkbox::code_one
PUBLIC	?code_zero@box_mkbox@@IAEXK@Z			; box_mkbox::code_zero
PUBLIC	?code@box_mkbox@@IAEXKK@Z			; box_mkbox::code
PUBLIC	?flush@box_mkbox@@IAEXXZ			; box_mkbox::flush
PUBLIC	?_shift_out@box_mkbox@@IAEXXZ			; box_mkbox::_shift_out
PUBLIC	??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z	; box_io::box_io
PUBLIC	?io_final@box_io@@IAEXXZ			; box_io::io_final
PUBLIC	?io_init@box_io@@IAEXXZ				; box_io::io_init
PUBLIC	?_putchr@box_io@@IAEXK@Z			; box_io::_putchr
PUBLIC	?_getchr@box_io@@IAEKXZ				; box_io::_getchr
PUBLIC	?_flushbuf@box_io@@IAEXXZ			; box_io::_flushbuf
PUBLIC	?_fillbuf@box_io@@IAEXXZ			; box_io::_fillbuf
PUBLIC	_printf
PUBLIC	__vfprintf_l
PUBLIC	___local_stdio_printf_options
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__PogoVCallTable
PUBLIC	__real@408f400000000000
EXTRN	__PogoGlobalProbes:PROC
EXTRN	__PogoRuntimeVector:PROC
EXTRN	___PogoPopAllXmm@0:PROC
EXTRN	___PogoPushAllXmm@0:PROC
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
rdata	SEGMENT
__PogoVCallTable DD FLAT:?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
	DD	FLAT:?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
	DD	FLAT:___local_stdio_printf_options
	DD	FLAT:_main
rdata	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT
; MDS probes
; __Stream$ = ecx
; __Format$ = edx

; 640  :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx
	push	72					; 00000048H
	call	DWORD PTR __PogoRuntimeVector+16

; 641  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	___local_stdio_printf_options
	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	esi
	push	edi
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	call	DWORD PTR __imp____stdio_common_vfprintf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 642  :     }

	pop	ebp
	mov	ecx, DWORD PTR [esp]
	mov	DWORD PTR [esp+8], ecx
	add	esp, 8
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?io_init@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_init@box_io@@IAEXXZ PROC				; box_io::io_init, COMDAT
; MDS probes
; _this$ = ecx

; 180  : 	__inline__ void io_init() {

	push	ebp
	mov	ebp, esp
	push	64					; 00000040H
	call	DWORD PTR __PogoRuntimeVector+16

; 181  : 		input->count = 0; // reset count

	mov	eax, DWORD PTR [ecx]

; 182  : 		output->count = 0; // reset count
; 183  : 		_fillbuf();

	push	DWORD PTR [ebp+12]
	push	1
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 184  : 	}

	pop	ebp
	ret	8
?io_init@box_io@@IAEXXZ ENDP				; box_io::io_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?io_final@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_final@box_io@@IAEXXZ PROC				; box_io::io_final, COMDAT
; MDS probes
; _this$ = ecx

; 187  : 	__inline__ void io_final() {

	push	ebp
	mov	ebp, esp
	push	88					; 00000058H
	call	DWORD PTR __PogoRuntimeVector+16

; 188  : 		if (output->count != 0) {

	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@io_final

; 189  : 			_flushbuf();

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
$LN2@io_final:

; 190  : 		}
; 191  : 	}

	pop	ebp
	ret	8
?io_final@box_io@@IAEXXZ ENDP				; box_io::io_final
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?flush@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?flush@box_mkbox@@IAEXXZ PROC				; box_mkbox::flush, COMDAT
; MDS probes
; _this$ = ecx

; 230  : 	__inline__ void flush() {

	push	ebp
	mov	ebp, esp
	push	120					; 00000078H
	call	DWORD PTR __PogoRuntimeVector+16

; 231  : 		_putchr(x1 >> 24);

	movzx	eax, BYTE PTR [ecx+31]
	push	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 232  : 	}

	pop	ebp
	ret	8
?flush@box_mkbox@@IAEXXZ ENDP				; box_mkbox::flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?fill_x@box_unbox@@IAEXXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
tv71 = -4						; size = 4
?fill_x@box_unbox@@IAEXXZ PROC				; box_unbox::fill_x, COMDAT
; MDS probes
; _this$ = ecx

; 460  : 	__inline__ void fill_x() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx
	push	112					; 00000070H
	call	DWORD PTR __PogoRuntimeVector+16

; 461  : 		for (int i = 0; i < 4; ++i) {

	xor	esi, esi
	mov	DWORD PTR tv71[ebp], 32			; 00000020H
	npad	5
$LL4@fill_x:
	cmp	esi, 4
	jge	SHORT $LN3@fill_x
	mov	DWORD PTR tv71[ebp], 24			; 00000018H

; 462  : 			x = (x << 8) | (_getchr() & 0xFF);

	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	movzx	ecx, al
	mov	eax, DWORD PTR [edi+20]
	shl	eax, 8
	or	eax, ecx
	inc	esi
	mov	DWORD PTR [edi+20], eax
	jmp	SHORT $LL4@fill_x
$LN3@fill_x:

; 461  : 		for (int i = 0; i < 4; ++i) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv71[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax

; 463  : 		}
; 464  : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?fill_x@box_unbox@@IAEXXZ ENDP				; box_unbox::fill_x
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?decompress@box_unbox@@IAEXXZ
_TEXT	SEGMENT
_cxt$1$ = -4						; size = 4
_chr$ = -4						; size = 4
?decompress@box_unbox@@IAEXXZ PROC			; box_unbox::decompress, COMDAT
; MDS probes
; _this$ = ecx

; 499  : 	__inline__ void decompress() {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	push	136					; 00000088H
	call	DWORD PTR __PogoRuntimeVector+16

; 500  : 		x1 = 0; x2 = 0xFFFFFFFF;
; 501  : 		fillmem(mem->htbl, HASH_SIZE, (U32) 0);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, 1048576				; 00100000H
	push	0
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [edi+12], 0
	push	11					; 0000000bH
	mov	DWORD PTR [edi+16], -1
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 502  : 		fillmem(mem->ptbl, SM_SIZE, (U32) 1 << 31);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, 131072				; 00020000H
	push	-2147483648				; 80000000H
	push	DWORD PTR [ebp+12]
	add	ecx, 4194304				; 00400000H
	push	10					; 0000000aH
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 503  : 		io_init();

	mov	eax, DWORD PTR [edi]
	add	esp, 8
	mov	ecx, edi
	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [edi+4]
	push	9
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf

; 504  : 		fill_x();

	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	5
	call	?fill_x@box_unbox@@IAEXXZ		; box_unbox::fill_x
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 505  : 
; 506  : 		U32 hash = 0, smc = 0, cxt = 0, chr;

	mov	ebx, DWORD PTR _chr$[ebp]
	xor	esi, esi
	xor	ecx, ecx
$LL2@decompress:

; 507  : 		while (1) {
; 508  : 
; 509  : 
; 510  : 
; 511  : 			mem->htbl[hash] = cxt;

	mov	eax, DWORD PTR [edi+8]

; 512  : 			hash = (((hash * 5) << HASH_SHIFT) + chr) & HASH_MASK;
; 513  : 			cxt = mem->htbl[hash];
; 514  : 			smc = ((chr << 4) | (cxt >> 24)) * SM_PART;
; 515  : 			_putchr(chr);

	push	ebx
	mov	DWORD PTR [eax+esi*4], ecx
	lea	esi, DWORD PTR [esi+esi*4]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, edi
	shl	esi, 5
	add	esi, ebx
	and	esi, 1048575				; 000fffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _cxt$1$[ebp], eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	3
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax

; 516  : 		}

	mov	ecx, DWORD PTR _cxt$1$[ebp]
	jmp	SHORT $LL2@decompress
?decompress@box_unbox@@IAEXXZ ENDP			; box_unbox::decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?code_zero@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_cxt$ = 16						; size = 4
?code_zero@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_zero, COMDAT
; MDS probes
; _this$ = ecx

; 244  : 	void code_zero(U32 cxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	push	152					; 00000098H
	call	DWORD PTR __PogoRuntimeVector+16

; 245  : 		U32 p = ptbl[cxt]; // prediction

	mov	edi, DWORD PTR [ecx+20]
	mov	esi, DWORD PTR _cxt$[ebp]

; 246  : 		ptbl[cxt] += (0 << 25) - (p >> 7); // update prediction
; 247  : 		x1 += ((x2 - x1) >> 12) * (p >> 20) + 1;
; 248  : 		_shift_out();

	push	DWORD PTR [ebp+12]
	push	1
	mov	ebx, DWORD PTR [edi+esi*4]
	mov	edx, ebx
	shr	edx, 7
	mov	eax, ebx
	sub	eax, edx
	shr	ebx, 20					; 00000014H
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [edi+esi*4], eax
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx+32]
	sub	eax, ecx
	inc	ecx
	shr	eax, 12					; 0000000cH
	imul	eax, ebx
	add	eax, ecx
	mov	ecx, edx
	mov	DWORD PTR [edx+28], eax
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?code_zero@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_zero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?code_one@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_cxt$ = 16						; size = 4
?code_one@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_one, COMDAT
; MDS probes
; _this$ = ecx

; 251  : 	void code_one(U32 cxt) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	push	144					; 00000090H
	call	DWORD PTR __PogoRuntimeVector+16

; 252  : 		U32 p = ptbl[cxt]; // prediction

	mov	edi, DWORD PTR [ecx+20]
	mov	esi, DWORD PTR _cxt$[ebp]

; 253  : 		ptbl[cxt] += (1 << 25) - (p >> 7); // update prediction
; 254  : 		x2 = x1 + ((x2 - x1) >> 12) * (p >> 20);
; 255  : 		_shift_out();

	push	DWORD PTR [ebp+12]
	push	1
	mov	ebx, DWORD PTR [edi+esi*4]
	mov	eax, ebx
	shr	eax, 7
	mov	edx, ebx
	sub	edx, eax
	shr	ebx, 20					; 00000014H
	add	edx, 33554432				; 02000000H
	mov	DWORD PTR [edi+esi*4], edx
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+32]
	sub	ecx, eax
	shr	ecx, 12					; 0000000cH
	imul	ecx, ebx
	add	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	ecx, eax
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 256  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?code_one@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_one
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?code_match@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
tv88 = -8						; size = 4
_this$1$ = -4						; size = 4
_i$1$ = 16						; size = 4
_smc$ = 16						; size = 4
_length$ = 20						; size = 4
?code_match@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_match, COMDAT
; MDS probes
; _this$ = ecx

; 281  : 	void code_match(U32 smc, U32 length) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx
	push	192					; 000000c0H
	call	DWORD PTR __PogoRuntimeVector+16

; 282  : 		assert(length > 0 && length <= MATCH_MAXI);
; 283  : 		code_one(smc);

	mov	edi, DWORD PTR _smc$[ebp]
	push	edi
	push	DWORD PTR [ebp+12]
	push	17					; 00000011H
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 284  : 		smc += 256;
; 285  : 		/*
; 286  : 		0
; 287  : 		100
; 288  : 		101
; 289  : 
; 290  : 		*/
; 291  : 
; 292  : 		if (length == 1) {

	mov	eax, DWORD PTR _length$[ebp]
	add	edi, 256				; 00000100H
	cmp	eax, 1
	jne	SHORT $LN8@code_match

; 293  : 			code_zero(smc);

	push	edi
	mov	ecx, ebx
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	9
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 294  : 		} else {

	jmp	$LN6@code_match
$LN8@code_match:

; 295  : 			U32 code_mask = 1;

	push	esi
	mov	esi, 1

; 296  : 			for (U32 mask = 1; mask < length; mask += mask + 1) {

	mov	DWORD PTR tv88[ebp], 56			; 00000038H
	mov	ebx, esi
	npad	4
$LL4@code_match:
	cmp	ebx, eax
	jae	SHORT $LN3@code_match

; 297  : 				code_one(smc);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	edi
	mov	DWORD PTR tv88[ebp], 48			; 00000030H
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	13					; 0000000dH
	call	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	pop	eax
	mov	eax, DWORD PTR _length$[ebp]
	lea	ebx, DWORD PTR [ebx*2+1]

; 298  : 				smc += code_mask;

	add	edi, esi

; 299  : 				code_mask += code_mask;

	add	esi, esi
	jmp	SHORT $LL4@code_match
$LN3@code_match:

; 296  : 			for (U32 mask = 1; mask < length; mask += mask + 1) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv88[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax

; 300  : 			}
; 301  : 			code_zero(smc);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	edi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	5
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax

; 302  : 
; 303  : 			if (code_mask < MATCH_MAXI) {

	cmp	esi, 256				; 00000100H
	jae	SHORT $LN18@code_match
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+80], 1
	adc	DWORD PTR [eax+84], 0
	pop	eax

; 304  : 				U32 i = 1;

	mov	ecx, 1
	mov	DWORD PTR _i$1$[ebp], ecx
$LL7@code_match:

; 305  : 				do {
; 306  : 					code_mask >>= 1;
; 307  : 					U32 bit = (length & code_mask) ? 1 : 0;

	mov	eax, DWORD PTR _length$[ebp]
	shr	esi, 1
	test	esi, eax
	je	SHORT $LN12@code_match
	mov	ebx, 1
	jmp	SHORT $LN13@code_match
$LN12@code_match:
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+88], 1
	adc	DWORD PTR [eax+92], 0
	pop	eax
	xor	ebx, ebx
$LN13@code_match:

; 308  : 					code(smc + i, bit);

	lea	eax, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	ebx
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+96], 1
	adc	DWORD PTR [eax+100], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+104], 1
	adc	DWORD PTR [eax+108], 0
	pop	eax

; 309  : 					i += i + bit;

	mov	ecx, DWORD PTR _i$1$[ebp]
	lea	ecx, DWORD PTR [ebx+ecx*2]
	mov	DWORD PTR _i$1$[ebp], ecx

; 310  : 				} while (i <= code_mask);

	cmp	ecx, esi
	jbe	SHORT $LL7@code_match
$LN18@code_match:
	pop	esi
$LN6@code_match:

; 311  : 			}
; 312  : 		}
; 313  : 	}

	pop	edi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?code_match@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?code_lit@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_smc$ = 16						; size = 4
_chr$ = 20						; size = 4
?code_lit@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_lit, COMDAT
; MDS probes
; _this$ = ecx

; 263  : 	void code_lit(U32 smc, U32 chr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 4
	push	ebx
	push	esi
	push	edi
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax
	push	184					; 000000b8H
	call	DWORD PTR __PogoRuntimeVector+16

; 264  : 		code_zero(smc);

	mov	edi, DWORD PTR _smc$[ebp]
	push	edi
	push	DWORD PTR [ebp+12]
	push	33					; 00000021H
	call	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 265  : 		// code high 4 bits in contexts cxt+1..15
; 266  : 		U32 block = ((chr & 0xFF) >> 4) | 16;

	mov	ebx, DWORD PTR _chr$[ebp]

; 267  : 		code(smc + 1, (block >> 3) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	and	ebx, 240				; 000000f0H
	or	ebx, 256				; 00000100H
	shr	ebx, 4
	mov	esi, ebx
	shr	esi, 3
	mov	eax, esi
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	DWORD PTR [ebp+12]
	push	29					; 0000001dH
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 268  : 		code(smc + (block >> 3), (block >> 2) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, ebx
	shr	edi, 2
	mov	eax, edi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	25					; 00000019H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 269  : 		code(smc + (block >> 2), (block >> 1) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	esi, ebx
	shr	esi, 1
	mov	eax, esi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, edi
	push	eax
	push	DWORD PTR [ebp+12]
	push	21					; 00000015H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0

; 270  : 		code(smc + (block >> 1), block & 1);

	mov	eax, ebx
	mov	edi, DWORD PTR _smc$[ebp]
	and	eax, 1
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	push	DWORD PTR [ebp+12]
	push	17					; 00000011H
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0
	pop	eax

; 271  : 		// code low 4 bits in one of 16 blocks of 15 cxts (to reduce cache misses)
; 272  : 		smc += 15 * (block - 15);

	lea	ecx, DWORD PTR [ebx-15]
	mov	eax, ecx
	shl	eax, 4
	sub	eax, ecx

; 273  : 		block = (chr & 15) | 16;

	mov	ebx, DWORD PTR _chr$[ebp]
	add	edi, eax

; 274  : 		code(smc + 1, (block >> 3) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	and	ebx, 15					; 0000000fH
	or	ebx, 16					; 00000010H
	mov	DWORD PTR _smc$[ebp], edi
	mov	esi, ebx
	shr	esi, 3
	mov	eax, esi
	and	eax, 1
	push	eax
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	DWORD PTR [ebp+12]
	push	13					; 0000000dH
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax

; 275  : 		code(smc + (block >> 3), (block >> 2) & 1);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	edi, ebx
	shr	edi, 2
	mov	eax, edi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, esi
	push	eax
	push	DWORD PTR [ebp+12]
	push	9
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax

; 276  : 		code(smc + (block >> 2), (block >> 1) & 1);

	mov	esi, ebx
	shr	esi, 1
	mov	eax, esi
	and	eax, 1
	push	eax
	mov	eax, DWORD PTR _smc$[ebp]
	add	eax, edi
	mov	edi, DWORD PTR _this$1$[ebp]
	push	eax
	push	DWORD PTR [ebp+12]
	mov	ecx, edi
	push	5
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax

; 277  : 		code(smc + (block >> 1), block & 1);

	mov	eax, DWORD PTR _smc$[ebp]
	and	ebx, 1
	push	ebx
	add	eax, esi
	mov	ecx, edi
	push	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 278  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?code_lit@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_lit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?code@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
_cxt$ = 16						; size = 4
_bit$ = 20						; size = 4
?code@box_mkbox@@IAEXKK@Z PROC				; box_mkbox::code, COMDAT
; MDS probes
; _this$ = ecx

; 235  : 	void code(U32 cxt, U32 bit) {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx
	push	168					; 000000a8H
	call	DWORD PTR __PogoRuntimeVector+16

; 236  : 		U32 p = ptbl[cxt]; // prediction

	mov	esi, DWORD PTR _cxt$[ebp]
	mov	edi, DWORD PTR [ebx+20]

; 237  : 		ptbl[cxt] += (bit << 25) - (p >> 7); // update prediction

	mov	edx, DWORD PTR _bit$[ebp]
	shl	edx, 25					; 00000019H
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	eax, ecx
	shr	eax, 7
	sub	edx, eax
	add	edx, ecx

; 238  : 		U32 xmid = x1 + ((x2 - x1) >> 12) * (p >> 20);

	shr	ecx, 20					; 00000014H
	mov	DWORD PTR [edi+esi*4], edx
	lea	esi, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR [ebx+28]
	mov	edx, DWORD PTR [esi]
	sub	edx, eax
	shr	edx, 12					; 0000000cH
	imul	edx, ecx

; 239  : 		*(bit ? &x2 : &x1) = xmid + (bit ? 0 : 1);

	mov	ecx, DWORD PTR _bit$[ebp]
	add	edx, eax
	test	ecx, ecx
	je	SHORT $LN5@code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	xor	eax, eax
	jmp	SHORT $LN6@code
$LN5@code:
	mov	eax, 1
$LN6@code:
	test	ecx, ecx
	jne	SHORT $LN4@code
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], ecx
	pop	eax
	lea	esi, DWORD PTR [ebx+28]
$LN4@code:
	add	eax, edx

; 240  : 		//bit ? x2 = xmid : x1 = xmid + 1;
; 241  : 		_shift_out();

	mov	ecx, ebx
	mov	DWORD PTR [esi], eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebx

; 242  : 	}

	pop	ebp
	ret	16					; 00000010H
?code@box_mkbox@@IAEXKK@Z ENDP				; box_mkbox::code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?_shift_out@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?_shift_out@box_mkbox@@IAEXXZ PROC			; box_mkbox::_shift_out, COMDAT
; MDS probes
; _this$ = ecx

; 218  : 	__inline__ void _shift_out() {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	128					; 00000080H
	call	DWORD PTR __PogoRuntimeVector+16

; 219  : 		if ((x1 ^ x2) > 0x00FFFFFF) {

	mov	eax, DWORD PTR [esi+28]
	xor	eax, DWORD PTR [esi+32]
	cmp	eax, 16777215				; 00ffffffH
	ja	SHORT $LN10@shift_out
	npad	2
$LL4@shift_out:

; 220  : 		} else {
; 221  : 			do {  // pass equal leading bytes of range
; 222  : 				_putchr(x1 >> 24);

	movzx	eax, BYTE PTR [esi+31]
	mov	ecx, esi
	push	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax

; 223  : 				x1 <<= 8;
; 224  : 				x2 = (x2 << 8) | 0xFF;

	mov	eax, DWORD PTR [esi+32]
	shl	DWORD PTR [esi+28], 8
	shl	eax, 8
	or	eax, 255				; 000000ffH
	mov	DWORD PTR [esi+32], eax

; 225  : 			} while ((x1 ^ x2) <= 0x00FFFFFF);

	xor	eax, DWORD PTR [esi+28]
	cmp	eax, 16777215				; 00ffffffH
	jbe	SHORT $LL4@shift_out

; 219  : 		if ((x1 ^ x2) > 0x00FFFFFF) {

	jmp	SHORT $LN3@shift_out
$LN10@shift_out:
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax
$LN3@shift_out:

; 226  : 		}
; 227  : 	}

	pop	esi
	pop	ebp
	ret	8
?_shift_out@box_mkbox@@IAEXXZ ENDP			; box_mkbox::_shift_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?_putchr@box_io@@IAEXK@Z
_TEXT	SEGMENT
_chr$ = 16						; size = 4
?_putchr@box_io@@IAEXK@Z PROC				; box_io::_putchr, COMDAT
; MDS probes
; _this$ = ecx

; 164  : 	__inline__ void _putchr(U32 chr) {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	96					; 00000060H
	call	DWORD PTR __PogoRuntimeVector+16

; 165  : 		if (output->count < output->size) { // is buffer not empty?

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [edx+12]
	jge	SHORT $LN2@putchr

; 166  : 			output->buffer[output->count++] = (U8) chr; // put chr to buffer

	mov	edx, DWORD PTR [edx+8]
	mov	al, BYTE PTR _chr$[ebp]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, DWORD PTR [esi+4]
	inc	DWORD PTR [eax+16]

; 167  : 		} else {

	jmp	SHORT $LN4@putchr
$LN2@putchr:

; 168  : 			_flushbuf(); // flush output buffer

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0

; 169  : 			assert(output->size > 0);
; 170  : 			if (output->size > 0) {

	mov	eax, DWORD PTR [esi+4]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN4@putchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 171  : 				output->count = 0; // reset count

	mov	DWORD PTR [eax+16], 0

; 172  : 				output->buffer[output->count++] = (U8) chr; // put chr to buffer

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+8]
	mov	al, BYTE PTR _chr$[ebp]
	mov	BYTE PTR [edx+ecx], al
	mov	eax, DWORD PTR [esi+4]
	inc	DWORD PTR [eax+16]
$LN4@putchr:

; 173  : 			} else {
; 174  : 				// well, dead end here, we lost a chr
; 175  : 			}
; 176  : 		}
; 177  : 	}

	pop	esi
	pop	ebp
	ret	12					; 0000000cH
?_putchr@box_io@@IAEXK@Z ENDP				; box_io::_putchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?_getchr@box_io@@IAEKXZ
_TEXT	SEGMENT
?_getchr@box_io@@IAEKXZ PROC				; box_io::_getchr, COMDAT
; MDS probes
; _this$ = ecx

; 149  : 	__inline__ U32 _getchr() {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	80					; 00000050H
	call	DWORD PTR __PogoRuntimeVector+16

; 150  : 		if (input->count < input->size) { // is buffer not empty?

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [edx+12]
	jge	SHORT $LN2@getchr

; 151  : 			return (U32) input->buffer[input->count++]; // get chr from buffer

	mov	eax, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [eax+ecx]
	inc	ecx
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN5@getchr
$LN2@getchr:

; 152  : 		} else {
; 153  : 			_fillbuf(); // fill input buffer

	mov	ecx, esi
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	push	DWORD PTR [ebp+12]
	push	1
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0

; 154  : 			if (input->size > 0) {

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN4@getchr
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0
	pop	eax

; 155  : 				input->count = 0; // reset count

	mov	DWORD PTR [eax+16], 0

; 156  : 				return (U32) input->buffer[input->count++]; // get chr from buffer

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx+8]
	movzx	eax, BYTE PTR [eax+ecx]
	inc	ecx
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN5@getchr
$LN4@getchr:

; 157  : 			} else {
; 158  : 				return (U32) 0xFFFFFFFF; // end of input

	or	eax, -1
$LN5@getchr:

; 159  : 			}
; 160  : 		}
; 161  : 	}

	pop	esi
	pop	ebp
	ret	8
?_getchr@box_io@@IAEKXZ ENDP				; box_io::_getchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?_flushbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_flushbuf@box_io@@IAEXXZ PROC				; box_io::_flushbuf, COMDAT
; MDS probes
; _this$ = ecx

; 144  : 	__inline__ void _flushbuf() {

	push	ebp
	mov	ebp, esp
	push	48					; 00000030H
	call	DWORD PTR __PogoRuntimeVector+16

; 145  : 		(*output->callback)(output);

	mov	eax, DWORD PTR [ecx+4]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+28
	call	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	add	esp, 4

; 146  : 	}

	pop	ebp
	ret	8
?_flushbuf@box_io@@IAEXXZ ENDP				; box_io::_flushbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?_fillbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_fillbuf@box_io@@IAEXXZ PROC				; box_io::_fillbuf, COMDAT
; MDS probes
; _this$ = ecx

; 139  : 	__inline__ void _fillbuf() {

	push	ebp
	mov	ebp, esp
	push	40					; 00000028H
	call	DWORD PTR __PogoRuntimeVector+16

; 140  : 		(*input->callback)(input);

	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [eax]
	push	eax
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+28
	call	eax
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	8
?_fillbuf@box_io@@IAEXXZ ENDP				; box_io::_fillbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
__input$ = 16						; size = 4
__output$ = 20						; size = 4
__mem$ = 24						; size = 4
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_unbox::box_unbox, COMDAT
; MDS probes
; _this$ = ecx

; 523  : 	__inline__ box_unbox(

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	160					; 000000a0H
	call	DWORD PTR __PogoRuntimeVector+16

; 524  : 		BOX_CALLBACK_STRUCT *_input, // input
; 525  : 		BOX_CALLBACK_STRUCT *_output, // output
; 526  : 		BOX_WORKMEM *_mem // workmem
; 527  : 	) : box_io(_input, _output), mem(_mem) {

	mov	eax, DWORD PTR __input$[ebp]

; 528  : 		decompress();

	push	DWORD PTR [ebp+12]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __output$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __mem$[ebp]
	push	1
	mov	DWORD PTR [esi+8], eax
	call	?decompress@box_unbox@@IAEXXZ		; box_unbox::decompress
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0

; 529  : 	}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	20					; 00000014H
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_unbox::box_unbox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
__input$ = 16						; size = 4
__output$ = 20						; size = 4
__mem$ = 24						; size = 4
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_mkbox::box_mkbox, COMDAT
; MDS probes
; _this$ = ecx

; 425  : 	__inline__ box_mkbox(

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	208					; 000000d0H
	call	DWORD PTR __PogoRuntimeVector+16

; 426  : 		BOX_CALLBACK_STRUCT *_input, // input
; 427  : 		BOX_CALLBACK_STRUCT *_output, // output
; 428  : 		BOX_WORKMEM *_mem // workmem
; 429  : 	) : box_io(_input, _output), mem(_mem) {

	mov	eax, DWORD PTR __input$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __output$[ebp]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR __mem$[ebp]
	mov	DWORD PTR [esi+8], eax

; 430  : 		compress();

	call	?compress@box_mkbox@@IAEXXZ		; box_mkbox::compress
	mov	eax, DWORD PTR [ebp+8]
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0

; 431  : 	}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	20					; 00000014H
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_mkbox::box_mkbox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ??$fillmem@K@@YAXPAKHK@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
tv70 = -4						; size = 4
_fill$ = 16						; size = 4
??$fillmem@K@@YAXPAKHK@Z PROC				; fillmem<unsigned long>, COMDAT
; MDS probes
; _pointer$ = ecx
; _size$ = edx

; 122  : static __inline__ void fillmem(type *pointer, int size, type fill) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	8
	call	DWORD PTR __PogoRuntimeVector+16

; 123  : 	for (int i = 0; i < size; i++) {

	mov	esi, DWORD PTR _fill$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv70[ebp], 32			; 00000020H
	mov	DWORD PTR tv71[ebp], 16			; 00000010H
$LL4@fillmem:
	cmp	eax, edx
	jge	SHORT $LN3@fillmem
	mov	DWORD PTR tv70[ebp], 24			; 00000018H
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv71[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	mov	DWORD PTR tv71[ebp], 8

; 124  : 		pointer[i] = fill;

	mov	DWORD PTR [ecx+eax*4], esi
	inc	eax
	jmp	SHORT $LL4@fillmem
$LN3@fillmem:

; 123  : 	for (int i = 0; i < size; i++) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv70[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax

; 125  : 	}
; 126  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	ecx, DWORD PTR [esp]
	mov	DWORD PTR [esp+8], ecx
	add	esp, 8
	ret	0
??$fillmem@K@@YAXPAKHK@Z ENDP				; fillmem<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ??$fillmem@E@@YAXPAEHE@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
tv70 = -4						; size = 4
_fill$ = 16						; size = 1
??$fillmem@E@@YAXPAEHE@Z PROC				; fillmem<unsigned char>, COMDAT
; MDS probes
; _pointer$ = ecx
; _size$ = edx

; 122  : static __inline__ void fillmem(type *pointer, int size, type fill) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	16					; 00000010H
	call	DWORD PTR __PogoRuntimeVector+16

; 123  : 	for (int i = 0; i < size; i++) {

	mov	bl, BYTE PTR _fill$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv70[ebp], 32			; 00000020H
	mov	DWORD PTR tv66[ebp], 16			; 00000010H
$LL4@fillmem:
	cmp	eax, edx
	jge	SHORT $LN3@fillmem
	mov	DWORD PTR tv70[ebp], 24			; 00000018H
	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv66[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
	mov	DWORD PTR tv66[ebp], 8

; 124  : 		pointer[i] = fill;

	mov	BYTE PTR [eax+ecx], bl
	inc	eax
	jmp	SHORT $LL4@fillmem
$LN3@fillmem:

; 123  : 	for (int i = 0; i < size; i++) {

	push	eax
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR tv70[ebp]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax

; 125  : 	}
; 126  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	mov	ecx, DWORD PTR [esp]
	mov	DWORD PTR [esp+8], ecx
	add	esp, 8
	ret	0
??$fillmem@E@@YAXPAEHE@Z ENDP				; fillmem<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT
; Plain probes

; 85   :     {

	call	DWORD PTR __PogoRuntimeVector+12
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+40], 1
	adc	DWORD PTR [eax+44], 0

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__vfprintf_l PROC					; COMDAT
; External Pogo thunk for __vfprintf_l
	pop	eax
	push	224					; 000000e0H
	push	0
	push	eax
	jmp	__vfprintf_l
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT
; Plain probes

; 952  :     {

	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+48], 1
	adc	DWORD PTR [eax+52], 0
	pop	eax

; 953  :         int _Result;
; 954  :         va_list _ArgList;
; 955  :         __crt_va_start(_ArgList, _Format);
; 956  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	lea	eax, DWORD PTR __Format$[esp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+56], 1
	adc	DWORD PTR [eax+60], 0
	pop	eax
	mov	edx, DWORD PTR __Format$[esp+8]
	add	esp, 4
	mov	ecx, eax
	push	185					; 000000b9H
	push	1
	call	__vfprintf_l
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+64], 1
	adc	DWORD PTR [eax+68], 0
	pop	eax
	add	esp, 8

; 957  :         __crt_va_end(_ArgList);
; 958  :         return _Result;
; 959  :     }

	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_fillbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_fillbuf@box_io@@IAEXXZ PROC				; box_io::_fillbuf, COMDAT
; External Pogo thunk for ?_fillbuf@box_io@@IAEXXZ
	pop	eax
	push	215					; 000000d7H
	push	0
	push	eax
	jmp	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf
?_fillbuf@box_io@@IAEXXZ ENDP				; box_io::_fillbuf
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_flushbuf@box_io@@IAEXXZ
_TEXT	SEGMENT
?_flushbuf@box_io@@IAEXXZ PROC				; box_io::_flushbuf, COMDAT
; External Pogo thunk for ?_flushbuf@box_io@@IAEXXZ
	pop	eax
	push	214					; 000000d6H
	push	0
	push	eax
	jmp	?_flushbuf@box_io@@IAEXXZ		; box_io::_flushbuf
?_flushbuf@box_io@@IAEXXZ ENDP				; box_io::_flushbuf
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_getchr@box_io@@IAEKXZ
_TEXT	SEGMENT
?_getchr@box_io@@IAEKXZ PROC				; box_io::_getchr, COMDAT
; External Pogo thunk for ?_getchr@box_io@@IAEKXZ
	pop	eax
	push	222					; 000000deH
	push	0
	push	eax
	jmp	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
?_getchr@box_io@@IAEKXZ ENDP				; box_io::_getchr
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_putchr@box_io@@IAEXK@Z
_TEXT	SEGMENT
?_putchr@box_io@@IAEXK@Z PROC				; box_io::_putchr, COMDAT
; External Pogo thunk for ?_putchr@box_io@@IAEXK@Z
	pop	eax
	push	220					; 000000dcH
	push	0
	push	eax
	jmp	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr
?_putchr@box_io@@IAEXK@Z ENDP				; box_io::_putchr
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?io_init@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_init@box_io@@IAEXXZ PROC				; box_io::io_init, COMDAT
; External Pogo thunk for ?io_init@box_io@@IAEXXZ
	pop	eax
	push	218					; 000000daH
	push	0
	push	eax
	jmp	?io_init@box_io@@IAEXXZ			; box_io::io_init
?io_init@box_io@@IAEXXZ ENDP				; box_io::io_init
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?io_final@box_io@@IAEXXZ
_TEXT	SEGMENT
?io_final@box_io@@IAEXXZ PROC				; box_io::io_final, COMDAT
; External Pogo thunk for ?io_final@box_io@@IAEXXZ
	pop	eax
	push	216					; 000000d8H
	push	0
	push	eax
	jmp	?io_final@box_io@@IAEXXZ		; box_io::io_final
?io_final@box_io@@IAEXXZ ENDP				; box_io::io_final
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z
_TEXT	SEGMENT
__input$ = 8						; size = 4
__output$ = 12						; size = 4
??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z PROC	; box_io::box_io, COMDAT
; _this$ = ecx

; 194  : 		BOX_CALLBACK_STRUCT *_input, // input
; 195  : 		BOX_CALLBACK_STRUCT *_output // output
; 196  : 	) : input(_input), output(_output) {}

	mov	eax, DWORD PTR __input$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __output$[esp-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	ret	8
??0box_io@@IAE@PAU_BOX_CALLBACK_STRUCT@@0@Z ENDP	; box_io::box_io
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?_shift_out@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?_shift_out@box_mkbox@@IAEXXZ PROC			; box_mkbox::_shift_out, COMDAT
; External Pogo thunk for ?_shift_out@box_mkbox@@IAEXXZ
	pop	eax
	push	231					; 000000e7H
	push	0
	push	eax
	jmp	?_shift_out@box_mkbox@@IAEXXZ		; box_mkbox::_shift_out
?_shift_out@box_mkbox@@IAEXXZ ENDP			; box_mkbox::_shift_out
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?flush@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
?flush@box_mkbox@@IAEXXZ PROC				; box_mkbox::flush, COMDAT
; External Pogo thunk for ?flush@box_mkbox@@IAEXXZ
	pop	eax
	push	228					; 000000e4H
	push	0
	push	eax
	jmp	?flush@box_mkbox@@IAEXXZ		; box_mkbox::flush
?flush@box_mkbox@@IAEXXZ ENDP				; box_mkbox::flush
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
?code@box_mkbox@@IAEXKK@Z PROC				; box_mkbox::code, COMDAT
; External Pogo thunk for ?code@box_mkbox@@IAEXKK@Z
	pop	eax
	push	254					; 000000feH
	push	0
	push	eax
	jmp	?code@box_mkbox@@IAEXKK@Z		; box_mkbox::code
?code@box_mkbox@@IAEXKK@Z ENDP				; box_mkbox::code
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_zero@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
?code_zero@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_zero, COMDAT
; External Pogo thunk for ?code_zero@box_mkbox@@IAEXK@Z
	pop	eax
	push	250					; 000000faH
	push	0
	push	eax
	jmp	?code_zero@box_mkbox@@IAEXK@Z		; box_mkbox::code_zero
?code_zero@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_zero
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_one@box_mkbox@@IAEXK@Z
_TEXT	SEGMENT
?code_one@box_mkbox@@IAEXK@Z PROC			; box_mkbox::code_one, COMDAT
; External Pogo thunk for ?code_one@box_mkbox@@IAEXK@Z
	pop	eax
	push	246					; 000000f6H
	push	0
	push	eax
	jmp	?code_one@box_mkbox@@IAEXK@Z		; box_mkbox::code_one
?code_one@box_mkbox@@IAEXK@Z ENDP			; box_mkbox::code_one
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_lit@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
?code_lit@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_lit, COMDAT
; External Pogo thunk for ?code_lit@box_mkbox@@IAEXKK@Z
	pop	eax
	push	292					; 00000124H
	push	0
	push	eax
	jmp	?code_lit@box_mkbox@@IAEXKK@Z		; box_mkbox::code_lit
?code_lit@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_lit
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?code_match@box_mkbox@@IAEXKK@Z
_TEXT	SEGMENT
?code_match@box_mkbox@@IAEXKK@Z PROC			; box_mkbox::code_match, COMDAT
; External Pogo thunk for ?code_match@box_mkbox@@IAEXKK@Z
	pop	eax
	push	271					; 0000010fH
	push	0
	push	eax
	jmp	?code_match@box_mkbox@@IAEXKK@Z		; box_mkbox::code_match
?code_match@box_mkbox@@IAEXKK@Z ENDP			; box_mkbox::code_match
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?compress@box_mkbox@@IAEXXZ
_TEXT	SEGMENT
_lpo$1$ = -48						; size = 4
_lpsize$1$ = -44					; size = 4
_hash$1$ = -40						; size = 4
_lpi$1$ = -36						; size = 4
_bufptr$1$ = -32					; size = 4
_chr$1$ = -28						; size = 4
tv574 = -24						; size = 4
tv576 = -20						; size = 4
tv412 = -16						; size = 4
tv413 = -12						; size = 4
tv414 = -8						; size = 4
tv415 = -4						; size = 4
?compress@box_mkbox@@IAEXXZ PROC			; box_mkbox::compress, COMDAT
; Plain probes
; _this$ = ecx

; 328  : 	__inline__ void compress() {

	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+88], 1
	adc	DWORD PTR [eax+92], 0
	pop	eax

; 329  : 		x1 = 0; x2 = 0xFFFFFFFF;
; 330  : 		htbl = mem->htbl;

	mov	ecx, DWORD PTR [edi+8]

; 331  : 		ptbl = mem->ptbl;
; 332  : 		ltbl = mem->ltbl;
; 333  : 		buffer = mem->buffer;
; 334  : 
; 335  : 		fillmem(buffer, BUFF_SIZE, (U8) 0);

	mov	edx, 16777216				; 01000000H
	push	0
	mov	DWORD PTR [edi+16], ecx
	push	5
	lea	eax, DWORD PTR [ecx+4194304]
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+20], eax
	lea	eax, DWORD PTR [ecx+21495808]
	add	ecx, 4718592				; 00480000H
	mov	DWORD PTR [edi+32], -1
	push	70					; 00000046H
	mov	DWORD PTR [edi+24], eax
	mov	DWORD PTR [edi+12], ecx
	call	??$fillmem@E@@YAXPAEHE@Z		; fillmem<unsigned char>

; 336  : 		fillmem(htbl, HASH_SIZE, (U32) 0);

	mov	ecx, DWORD PTR [edi+16]
	mov	edx, 1048576				; 00100000H
	push	0
	push	5
	push	69					; 00000045H
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 337  : 		fillmem(ptbl, SM_SIZE, (U32) 1 << 31);

	mov	ecx, DWORD PTR [edi+20]
	mov	edx, 131072				; 00020000H
	push	-2147483648				; 80000000H
	push	5
	push	68					; 00000044H
	call	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>

; 338  : 		io_init();

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	mov	ecx, edi
	mov	DWORD PTR [eax+16], 0
	mov	eax, DWORD PTR [edi+4]
	push	5
	push	67					; 00000043H
	mov	DWORD PTR [eax+16], 0
	call	?_fillbuf@box_io@@IAEXXZ		; box_io::_fillbuf

; 339  : 
; 340  : 		U32 bufptr = BUFF_MASK;
; 341  : 		U32 hash = 0;
; 342  : 
; 343  : 		U32 lpi = 0, lpo = 0, lpsize = 0;

	xor	ebp, ebp
	mov	DWORD PTR _bufptr$1$[esp+64], 16777215	; 00ffffffH
	xor	ebx, ebx
	mov	DWORD PTR _hash$1$[esp+64], 0
	mov	DWORD PTR _lpi$1$[esp+64], 0
	mov	DWORD PTR _lpo$1$[esp+64], ebp
	mov	DWORD PTR _lpsize$1$[esp+64], ebx
	npad	5
$LL2@compress:

; 344  : 		// state:
; 345  : 		// empty (lpi == lpo)
; 346  : 		// not empty (lpi != lpo)
; 347  : 		// NEVER full
; 348  : 
; 349  : 		// current char
; 350  : 		U32 chr;
; 351  : 		while ((chr = _getchr()) <= 0xFF) {

	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+96], 1
	adc	DWORD PTR [eax+100], 0
	pop	eax
	push	5
	push	64					; 00000040H
	call	?_getchr@box_io@@IAEKXZ			; box_io::_getchr
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+104], 1
	adc	DWORD PTR [eax+108], 0
	pop	eax
	mov	edx, eax
	mov	DWORD PTR _chr$1$[esp+64], edx
	cmp	edx, 255				; 000000ffH
	ja	$LN3@compress

; 352  : 			// lastchar == buffer[bufptr]
; 353  : 			bool is_equal = (buffer[htbl[hash]] == chr);

	mov	ecx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR _hash$1$[esp+64]
	mov	esi, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [ecx+eax*4]
	movzx	ecx, BYTE PTR [ecx+esi]
	cmp	ecx, edx
	jne	SHORT $LN18@compress
	mov	dl, 1
	jmp	SHORT $LN19@compress
$LN18@compress:
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+112], 1
	adc	DWORD PTR [eax+116], 0
	pop	eax
	xor	dl, dl
$LN19@compress:

; 354  : 			ltbl[lpi].len = ((buffer[bufptr] << LIT_BITS) | chr) 

	mov	eax, 65536				; 00010000H
	test	dl, dl
	jne	SHORT $LN21@compress
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+120], 1
	adc	DWORD PTR [eax+124], 0
	mov	eax, 67108864				; 04000000H
$LN21@compress:
	mov	ecx, DWORD PTR _bufptr$1$[esp+64]
	movzx	ecx, BYTE PTR [esi+ecx]
	mov	esi, DWORD PTR _lpi$1$[esp+64]
	shl	ecx, 8
	or	ecx, DWORD PTR _chr$1$[esp+64]
	add	ecx, eax
	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [eax+esi*8], ecx

; 355  : 				+ (is_equal ? LM_INCR : LM_LOCK);
; 356  : 			if (is_equal) {

	test	dl, dl
	je	SHORT $LN10@compress
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+128], 1
	adc	DWORD PTR [eax+132], 0

; 357  : 				ltbl[lpi].ptr = (htbl[hash] + 1) & BUFF_MASK;

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR _hash$1$[esp+64]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edi+24]
	inc	ecx
	and	ecx, 16777215				; 00ffffffH

; 358  : 				lpsize += 1;

	inc	ebx
	mov	DWORD PTR _lpsize$1$[esp+64], ebx
	mov	DWORD PTR [eax+esi*8+4], ecx
$LN10@compress:

; 359  : 			}
; 360  : 
; 361  : 			for (
; 362  : 				U32 lpm = (lpi - 1) & LAZY_MASK, cnt = 0;

	lea	eax, DWORD PTR [esi-1]

; 363  : 				lpm != lpo && cnt < lpsize;

	mov	DWORD PTR tv412[esp+64], 184		; 000000b8H
	and	eax, 511				; 000001ffH
	xor	esi, esi
$LL6@compress:
	cmp	eax, ebp
	je	$LN37@compress
	mov	DWORD PTR tv412[esp+64], 176		; 000000b0H
	cmp	esi, ebx
	jae	$LN5@compress

; 365  : 			) {
; 366  : 				if (ltbl[lpm].len < LM_MAXI) {

	mov	ebp, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [ebp+eax*8]
	cmp	ecx, 16777216				; 01000000H
	jae	$LN38@compress

; 367  : 					bool is_equal = (buffer[ltbl[lpm].ptr] == chr);

	mov	edx, DWORD PTR [ebp+eax*8+4]
	mov	ecx, DWORD PTR [edi+12]
	movzx	ecx, BYTE PTR [edx+ecx]
	cmp	ecx, DWORD PTR _chr$1$[esp+64]
	jne	SHORT $LN22@compress
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+136], 1
	adc	DWORD PTR [eax+140], 0
	pop	eax
	mov	bl, 1
	jmp	SHORT $LN23@compress
$LN22@compress:
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+144], 1
	adc	DWORD PTR [eax+148], 0
	pop	eax
	xor	bl, bl
$LN23@compress:

; 368  : 					ltbl[lpm].len += is_equal ? LM_INCR : LM_LOCK;

	mov	ecx, 65536				; 00010000H
	test	bl, bl
	jne	SHORT $LN25@compress
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+152], 1
	adc	DWORD PTR [eax+156], 0
	pop	eax
	mov	ecx, 67108864				; 04000000H
$LN25@compress:
	add	DWORD PTR [ebp+eax*8], ecx

; 369  : 					ltbl[lpm].ptr = (ltbl[lpm].ptr + 1) & BUFF_MASK;

	mov	edx, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	inc	ecx
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR [edx+eax*8+4], ecx

; 370  : 					if (!is_equal) {

	test	bl, bl
	jne	SHORT $LN36@compress
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+160], 1
	adc	DWORD PTR [eax+164], 0
	pop	eax

; 371  : 						lpsize -= 1;

	mov	ebx, DWORD PTR _lpsize$1$[esp+64]
	dec	ebx

; 372  : 						cnt -= 1;

	dec	esi
	mov	DWORD PTR _lpsize$1$[esp+64], ebx
	jmp	SHORT $LN4@compress
$LN36@compress:

; 370  : 					if (!is_equal) {

	mov	ebx, DWORD PTR _lpsize$1$[esp+64]

; 365  : 			) {
; 366  : 				if (ltbl[lpm].len < LM_MAXI) {

	jmp	SHORT $LN4@compress
$LN38@compress:
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+168], 1
	adc	DWORD PTR [eax+172], 0
	pop	eax
$LN4@compress:

; 364  : 				lpm = (lpm - 1) & LAZY_MASK, cnt += 1

	mov	ebp, DWORD PTR _lpo$1$[esp+64]
	dec	eax
	and	eax, 511				; 000001ffH
	inc	esi
	jmp	$LL6@compress
$LN37@compress:

; 363  : 				lpm != lpo && cnt < lpsize;

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	eax, DWORD PTR tv412[esp+68]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax
$LN5@compress:

; 373  : 					}
; 374  : 				}
; 375  : 			}
; 376  : 
; 377  : 			lpi = (lpi + 1) & LAZY_MASK;

	mov	ecx, DWORD PTR _lpi$1$[esp+64]
	inc	ecx
	and	ecx, 511				; 000001ffH
	mov	DWORD PTR _lpi$1$[esp+64], ecx

; 378  : 			// state:
; 379  : 			// empty (lpi == lpo)
; 380  : 			// not empty (lpi != lpo)
; 381  : 			// NEVER full
; 382  : 			if (lpi == lpo) {

	cmp	ecx, ebp
	jne	$LN16@compress

; 383  : 				// full, flush out
; 384  : 				U32 max_score = ltbl[(lpo + 1) & LAZY_MASK].len & LM_MASK;

	lea	eax, DWORD PTR [ebp+1]

; 385  : 				U32 max_len = 0;
; 386  : 				for (U32 curr_len = ltbl[lpo].len & LM_MASK; curr_len > 0; curr_len -= LM_INCR) {

	mov	DWORD PTR tv414[esp+64], 216		; 000000d8H
	mov	ebp, DWORD PTR [edi+24]
	and	eax, 511				; 000001ffH
	mov	DWORD PTR tv576[esp+64], eax
	xor	ebx, ebx
	mov	esi, DWORD PTR [ebp+eax*8]
	mov	eax, DWORD PTR _lpo$1$[esp+64]
	and	esi, 33488896				; 01ff0000H
	mov	ecx, DWORD PTR [ebp+eax*8]
	mov	DWORD PTR tv574[esp+64], ecx
	and	ecx, 33488896				; 01ff0000H
	lea	edx, DWORD PTR [ecx+eax]
$LL9@compress:
	test	ecx, ecx
	jbe	SHORT $LN8@compress

; 387  : 					U32 curr_score = curr_len + ltbl[(lpo + curr_len) & LAZY_MASK].len & LM_MASK;

	mov	eax, edx
	mov	DWORD PTR tv414[esp+64], 208		; 000000d0H
	and	eax, 511				; 000001ffH
	mov	eax, DWORD PTR [ebp+eax*8]
	add	eax, ecx
	and	eax, 33488896				; 01ff0000H

; 388  : 					if (max_score < curr_score) {

	cmp	esi, eax
	jae	SHORT $LN39@compress
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+192], 1
	adc	DWORD PTR [eax+196], 0
	pop	eax

; 389  : 						max_score = curr_score;

	mov	esi, eax

; 390  : 						max_len = curr_len;

	mov	ebx, ecx
	jmp	SHORT $LN7@compress
$LN39@compress:

; 388  : 					if (max_score < curr_score) {

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+200], 1
	adc	DWORD PTR [eax+204], 0
	pop	eax
$LN7@compress:

; 385  : 				U32 max_len = 0;
; 386  : 				for (U32 curr_len = ltbl[lpo].len & LM_MASK; curr_len > 0; curr_len -= LM_INCR) {

	sub	ecx, 65536				; 00010000H
	sub	edx, 65536				; 00010000H
	jmp	SHORT $LL9@compress
$LN8@compress:
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	eax, DWORD PTR tv414[esp+68]
	add	DWORD PTR [eax], 1
	adc	DWORD PTR [eax+4], 0
	pop	eax

; 391  : 					}
; 392  : 				}
; 393  : 
; 394  : 				if (max_len > 0) {

	test	ebx, ebx
	jbe	SHORT $LN15@compress

; 395  : 					// encode match
; 396  : 					U32 smc = ((ltbl[lpo].len >> LIT_BITS) & LIT_MASK) * SM_PART;

	mov	eax, DWORD PTR _lpo$1$[esp+64]

; 397  : 					U32 mlen = max_len >> LM_SHIFT;
; 398  : 					code_match(smc, mlen);

	mov	ecx, edi
	shr	ebx, 16					; 00000010H
	push	ebx
	movzx	eax, BYTE PTR [ebp+eax*8+1]
	shl	eax, 9
	push	eax
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+224], 1
	adc	DWORD PTR [eax+228], 0
	pop	eax
	push	5
	push	43					; 0000002bH
	call	?code_match@box_mkbox@@IAEXKK@Z		; box_mkbox::code_match
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+232], 1
	adc	DWORD PTR [eax+236], 0
	pop	eax

; 399  : 
; 400  : 					lpo = (lpo + mlen) & LAZY_MASK;

	mov	ebp, DWORD PTR _lpo$1$[esp+64]
	add	ebp, ebx

; 401  : 				} else {

	mov	ebx, DWORD PTR _lpsize$1$[esp+64]
	and	ebp, 511				; 000001ffH
	mov	DWORD PTR _lpo$1$[esp+64], ebp
	jmp	SHORT $LN16@compress
$LN15@compress:

; 402  : 					// encode literal
; 403  : 					U32 smc = ((ltbl[lpo].len >> LIT_BITS) & LIT_MASK) * SM_PART;

	mov	eax, DWORD PTR _lpo$1$[esp+64]
	movzx	ecx, BYTE PTR [ebp+eax*8+1]

; 404  : 					U32 mchr = ltbl[lpo].len & LIT_MASK;

	mov	eax, DWORD PTR tv574[esp+64]
	movzx	eax, al
	shl	ecx, 9

; 405  : 					code_lit(smc, mchr);

	push	eax
	push	ecx
	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+240], 1
	adc	DWORD PTR [eax+244], 0
	pop	eax
	push	5
	push	6
	call	?code_lit@box_mkbox@@IAEXKK@Z		; box_mkbox::code_lit
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+248], 1
	adc	DWORD PTR [eax+252], 0
	pop	eax

; 406  : 
; 407  : 					lpo = (lpo + 1) & LAZY_MASK;

	mov	ebp, DWORD PTR tv576[esp+64]
	mov	ebx, DWORD PTR _lpsize$1$[esp+64]
	mov	DWORD PTR _lpo$1$[esp+64], ebp
$LN16@compress:

; 408  : 				}
; 409  : 			}
; 410  : 
; 411  : 			bufptr = (bufptr + 1) & BUFF_MASK;

	mov	edx, DWORD PTR _bufptr$1$[esp+64]

; 412  : 			htbl[hash] = bufptr;

	mov	eax, DWORD PTR [edi+16]
	inc	edx
	mov	esi, DWORD PTR _hash$1$[esp+64]
	and	edx, 16777215				; 00ffffffH

; 413  : 			hash = (((hash * 5) << HASH_SHIFT) + chr) & HASH_MASK;

	mov	ecx, DWORD PTR _chr$1$[esp+64]
	mov	DWORD PTR _bufptr$1$[esp+64], edx
	mov	DWORD PTR [eax+esi*4], edx
	lea	esi, DWORD PTR [esi+esi*4]

; 414  : 			buffer[bufptr] = (U8) chr;

	mov	eax, DWORD PTR [edi+12]
	shl	esi, 5
	add	esi, ecx
	and	esi, 1048575				; 000fffffH
	mov	DWORD PTR _hash$1$[esp+64], esi
	mov	BYTE PTR [edx+eax], cl

; 415  : 		}

	jmp	$LL2@compress
$LN3@compress:

; 416  : 		// mark EOF
; 417  : 		///////////////
; 418  : 		// finalize
; 419  : 		flush();

	movzx	eax, BYTE PTR [edi+31]
	mov	ecx, edi
	push	eax
	push	5
	push	4
	call	?_putchr@box_io@@IAEXK@Z		; box_io::_putchr

; 420  : 		io_final();

	mov	ecx, edi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+256], 1
	adc	DWORD PTR [eax+260], 0
	pop	eax
	push	5
	push	1
	call	?io_final@box_io@@IAEXXZ		; box_io::io_final
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+264], 1
	adc	DWORD PTR [eax+268], 0
	pop	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 421  : 	}

	add	esp, 48					; 00000030H
	ret	0
?compress@box_mkbox@@IAEXXZ ENDP			; box_mkbox::compress
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_mkbox::box_mkbox, COMDAT
; External Pogo thunk for ??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
	pop	eax
	push	329					; 00000149H
	push	0
	push	eax
	jmp	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_mkbox::box_mkbox
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?fill_x@box_unbox@@IAEXXZ
_TEXT	SEGMENT
?fill_x@box_unbox@@IAEXXZ PROC				; box_unbox::fill_x, COMDAT
; External Pogo thunk for ?fill_x@box_unbox@@IAEXXZ
	pop	eax
	push	225					; 000000e1H
	push	0
	push	eax
	jmp	?fill_x@box_unbox@@IAEXXZ		; box_unbox::fill_x
?fill_x@box_unbox@@IAEXXZ ENDP				; box_unbox::fill_x
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ?decompress@box_unbox@@IAEXXZ
_TEXT	SEGMENT
?decompress@box_unbox@@IAEXXZ PROC			; box_unbox::decompress, COMDAT
; External Pogo thunk for ?decompress@box_unbox@@IAEXXZ
	pop	eax
	push	234					; 000000eaH
	push	0
	push	eax
	jmp	?decompress@box_unbox@@IAEXXZ		; box_unbox::decompress
?decompress@box_unbox@@IAEXXZ ENDP			; box_unbox::decompress
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
_TEXT	SEGMENT
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z PROC ; box_unbox::box_unbox, COMDAT
; External Pogo thunk for ??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z
	pop	eax
	push	258					; 00000102H
	push	0
	push	eax
	jmp	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ENDP ; box_unbox::box_unbox
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?box_workmem_size@@YAKXZ
_TEXT	SEGMENT
?box_workmem_size@@YAKXZ PROC				; box_workmem_size, COMDAT

; 536  : 	return sizeof(BOX_WORKMEM);

	mov	eax, 21499904				; 01481000H

; 537  : }

	ret	0
?box_workmem_size@@YAKXZ ENDP				; box_workmem_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z
_TEXT	SEGMENT
_mkbox$ = -36						; size = 36
__mem$ = 8						; size = 4
?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z PROC	; box_compress, COMDAT
; Plain probes
; __input$ = ecx
; __output$ = edx

; 543  : ) {

	sub	esp, 36					; 00000024H
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+272], 1
	adc	DWORD PTR [eax+276], 0
	pop	eax

; 544  : 	box_mkbox mkbox(_input, _output, (BOX_WORKMEM*) _mem);

	push	DWORD PTR __mem$[esp+32]
	push	edx
	push	ecx
	push	2
	lea	ecx, DWORD PTR _mkbox$[esp+52]
	push	1
	call	??0box_mkbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_mkbox::box_mkbox
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+280], 1
	adc	DWORD PTR [eax+284], 0
	pop	eax

; 545  : }

	add	esp, 36					; 00000024H
	ret	0
?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ENDP	; box_compress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\box_rolz_lookback.h
;	COMDAT ?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z
_TEXT	SEGMENT
_unbox$ = -24						; size = 24
__mem$ = 8						; size = 4
?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z PROC ; box_decompress, COMDAT
; Plain probes
; __input$ = ecx
; __output$ = edx

; 551  : ) {

	sub	esp, 24					; 00000018H
	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+72], 1
	adc	DWORD PTR [eax+76], 0
	pop	eax

; 552  : 	box_unbox unbox(_input, _output, (BOX_WORKMEM*) _mem);

	push	DWORD PTR __mem$[esp+20]
	push	edx
	push	ecx
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _unbox$[esp+40]
	push	1
	call	??0box_unbox@@QAE@PAU_BOX_CALLBACK_STRUCT@@0PAU_BOX_WORKMEM@@@Z ; box_unbox::box_unbox
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+80], 1
	adc	DWORD PTR [eax+84], 0
	pop	eax

; 553  : }

	add	esp, 24					; 00000018H
	ret	0
?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ENDP ; box_decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT ?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z PROC	; input_proc, COMDAT
; Plain probes

; 13   : 	input->size = fread(input->buffer, sizeof(char), input->size, (FILE*) input->handle);

	push	esi

; 12   : void __cdecl input_proc(BOX_CALLBACK_STRUCT *input) {

	call	DWORD PTR __PogoRuntimeVector+12
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+8], 1
	adc	DWORD PTR [eax+12], 0
	pop	eax

; 13   : 	input->size = fread(input->buffer, sizeof(char), input->size, (FILE*) input->handle);

	mov	esi, DWORD PTR _input$[esp]
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi+12]
	push	1
	push	DWORD PTR [esi+8]
	call	DWORD PTR __imp__fread
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+16], 1
	adc	DWORD PTR [eax+20], 0
	pop	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+12], eax
	pop	esi

; 14   : }

	ret	0
?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ENDP	; input_proc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT ?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z
_TEXT	SEGMENT
_output$ = 8						; size = 4
?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z PROC	; output_proc, COMDAT
; Plain probes

; 16   : void __cdecl output_proc(BOX_CALLBACK_STRUCT *output) {

	call	DWORD PTR __PogoRuntimeVector+12
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+24], 1
	adc	DWORD PTR [eax+28], 0

; 17   : 	fwrite(output->buffer, sizeof(char), output->count, (FILE*) output->handle);

	mov	eax, DWORD PTR _output$[esp-4]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax+16]
	push	1
	push	DWORD PTR [eax+8]
	call	DWORD PTR __imp__fwrite
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+32], 1
	adc	DWORD PTR [eax+36], 0
	pop	eax
	add	esp, 16					; 00000010H

; 18   : }

	ret	0
?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ENDP	; output_proc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\___x\hack\appupdt\box\box\box\main.cpp
;	COMDAT _main
_TEXT	SEGMENT
_in$1$ = -52						; size = 4
_inbuf$1$ = -48						; size = 4
_start$1$ = -44						; size = 4
_output$ = -40						; size = 20
_input$ = -20						; size = 20
_outbuf$1$ = 8						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT
; Plain probes

; 21   : int main(int argc, char **argv) {

	sub	esp, 52					; 00000034H
	push	edi
	call	___PogoPushAllXmm@0
	call	DWORD PTR __PogoRuntimeVector+12
	call	___PogoPopAllXmm@0
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+288], 1
	adc	DWORD PTR [eax+292], 0
	pop	eax

; 22   : 
; 23   : 	// Check arguments
; 24   : 	if ((argc != 4) || ((argv[1][0] != 'c') && (argv[1][0] != 'd'))) {

	cmp	DWORD PTR _argc$[esp+52], 4
	jne	$LN3@main
	mov	edi, DWORD PTR _argv$[esp+52]
	mov	eax, DWORD PTR [edi+4]
	mov	al, BYTE PTR [eax]
	cmp	al, 99					; 00000063H
	je	SHORT $LN2@main
	cmp	al, 100					; 00000064H
	jne	$LN12@main
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+296], 1
	adc	DWORD PTR [eax+300], 0
	pop	eax
$LN2@main:

; 27   : 	}
; 28   : 
; 29   : 	// Get start time
; 30   : 	clock_t start = clock();

	push	esi
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+304], 1
	adc	DWORD PTR [eax+308], 0
	call	DWORD PTR __imp__clock
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+312], 1
	adc	DWORD PTR [eax+316], 0
	pop	eax

; 31   : 
; 32   : 	// Compress
; 33   : 	FILE *in = fopen(argv[2], "rb");

	mov	esi, DWORD PTR __imp__fopen
	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	DWORD PTR [edi+8]
	mov	DWORD PTR _start$1$[esp+68], eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+320], 1
	adc	DWORD PTR [eax+324], 0
	pop	eax
	add	esp, 8
	mov	DWORD PTR _in$1$[esp+60], eax

; 34   : 	if (!in) perror(argv[2]), exit(1);

	test	eax, eax
	jne	SHORT $LN4@main
	push	DWORD PTR [edi+8]
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+328], 1
	adc	DWORD PTR [eax+332], 0
	pop	eax
	call	DWORD PTR __imp__perror
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+336], 1
	adc	DWORD PTR [eax+340], 0
	pop	eax
	add	esp, 4
	push	1
	call	DWORD PTR __imp__exit
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+344], 1
	adc	DWORD PTR [eax+348], 0
	pop	eax
$LN13@main:
$LN4@main:

; 35   : 	FILE *out = fopen(argv[3], "wb");

	push	ebp
	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	DWORD PTR [edi+12]
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+352], 1
	adc	DWORD PTR [eax+356], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+360], 1
	adc	DWORD PTR [eax+364], 0
	pop	eax
	mov	ebp, eax
	add	esp, 8

; 36   : 	if (!out) perror(argv[3]), exit(1);

	test	ebp, ebp
	jne	SHORT $LN5@main
	push	DWORD PTR [edi+12]
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+368], 1
	adc	DWORD PTR [eax+372], ebp
	pop	eax
	call	DWORD PTR __imp__perror
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+376], 1
	adc	DWORD PTR [eax+380], ebp
	pop	eax
	add	esp, 4
	push	1
	call	DWORD PTR __imp__exit
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+384], 1
	adc	DWORD PTR [eax+388], ebp
	pop	eax
$LN14@main:
$LN5@main:

; 37   : 
; 38   : 	unsigned char *inbuf = (unsigned char *) malloc(1 << 20);

	mov	esi, DWORD PTR __imp__malloc
	push	ebx
	push	1048576					; 00100000H
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+392], 1
	adc	DWORD PTR [eax+396], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+400], 1
	adc	DWORD PTR [eax+404], 0
	pop	eax

; 39   : 	unsigned char *outbuf = (unsigned char *) malloc(1 << 20);

	push	1048576					; 00100000H
	mov	DWORD PTR _inbuf$1$[esp+76], eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+408], 1
	adc	DWORD PTR [eax+412], 0
	pop	eax
	mov	DWORD PTR _outbuf$1$[esp+72], eax

; 40   : 	void *mem = malloc(box_workmem_size());

	call	?box_workmem_size@@YAKXZ		; box_workmem_size
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+416], 1
	adc	DWORD PTR [eax+420], 0
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+424], 1
	adc	DWORD PTR [eax+428], 0
	pop	eax

; 41   : 
; 42   : 	BOX_CALLBACK_STRUCT input;
; 43   : 	input.callback = &input_proc;
; 44   : 	input.handle = (void*) in;
; 45   : 	input.buffer = inbuf;
; 46   : 	input.size = 1 << 20;
; 47   : 
; 48   : 	BOX_CALLBACK_STRUCT output;
; 49   : 	output.callback = &output_proc;
; 50   : 	output.handle = (void*) out;
; 51   : 	output.buffer = outbuf;
; 52   : 	output.size = 1 << 20;
; 53   : 
; 54   : 	if (argv[1][0] == 'c') {

	mov	ecx, DWORD PTR [edi+4]
	mov	ebx, eax
	mov	eax, DWORD PTR _in$1$[esp+80]
	add	esp, 12					; 0000000cH
	mov	esi, DWORD PTR _inbuf$1$[esp+68]
	mov	DWORD PTR _input$[esp+72], eax
	mov	eax, DWORD PTR _outbuf$1$[esp+64]
	mov	DWORD PTR _input$[esp+68], OFFSET ?input_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ; input_proc
	mov	DWORD PTR _input$[esp+76], esi
	mov	DWORD PTR _input$[esp+80], 1048576	; 00100000H
	mov	DWORD PTR _output$[esp+68], OFFSET ?output_proc@@YAXPAU_BOX_CALLBACK_STRUCT@@@Z ; output_proc
	mov	DWORD PTR _output$[esp+72], ebp
	mov	DWORD PTR _output$[esp+76], eax
	mov	DWORD PTR _output$[esp+80], 1048576	; 00100000H
	cmp	BYTE PTR [ecx], 99			; 00000063H
	jne	SHORT $LN6@main

; 55   : 		box_compress(&input, &output, mem);

	push	ebx
	lea	edx, DWORD PTR _output$[esp+72]
	lea	ecx, DWORD PTR _input$[esp+72]
	call	?box_compress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_compress
	add	esp, 4

; 56   : 	} else {

	jmp	SHORT $LN7@main
$LN6@main:

; 41   : 
; 42   : 	BOX_CALLBACK_STRUCT input;
; 43   : 	input.callback = &input_proc;
; 44   : 	input.handle = (void*) in;
; 45   : 	input.buffer = inbuf;
; 46   : 	input.size = 1 << 20;
; 47   : 
; 48   : 	BOX_CALLBACK_STRUCT output;
; 49   : 	output.callback = &output_proc;
; 50   : 	output.handle = (void*) out;
; 51   : 	output.buffer = outbuf;
; 52   : 	output.size = 1 << 20;
; 53   : 
; 54   : 	if (argv[1][0] == 'c') {

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+432], 1
	adc	DWORD PTR [eax+436], 0
	pop	eax

; 57   : 		box_decompress(&input, &output, mem);

	push	ebx
	lea	edx, DWORD PTR _output$[esp+72]
	lea	ecx, DWORD PTR _input$[esp+72]
	call	?box_decompress@@YAXPAU_BOX_CALLBACK_STRUCT@@0PAX@Z ; box_decompress
	add	esp, 4
$LN7@main:

; 58   : 	}
; 59   : 
; 60   : 	free(inbuf);

	push	esi
	mov	esi, DWORD PTR __imp__free
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+440], 1
	adc	DWORD PTR [eax+444], 0
	pop	eax
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+448], 1
	adc	DWORD PTR [eax+452], 0
	pop	eax

; 61   : 	free(outbuf);

	push	DWORD PTR _outbuf$1$[esp+68]
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+456], 1
	adc	DWORD PTR [eax+460], 0
	pop	eax

; 62   : 	free(mem);

	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+464], 1
	adc	DWORD PTR [eax+468], 0
	pop	eax

; 63   : 
; 64   : 	// Report result
; 65   : 	printf("%ld -> %ld in %1.2f sec.\n",

	call	DWORD PTR __imp__clock
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+472], 1
	adc	DWORD PTR [eax+476], 0
	pop	eax
	sub	eax, DWORD PTR _start$1$[esp+80]
	add	esp, 4
	mov	esi, DWORD PTR __imp__ftell
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR [esp], xmm0
	push	ebp
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+480], 1
	adc	DWORD PTR [eax+484], 0
	pop	eax
	mov	ebx, DWORD PTR _in$1$[esp+80]
	add	esp, 4
	push	eax
	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+488], 1
	adc	DWORD PTR [eax+492], 0
	pop	eax
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_0BK@PKBENODM@?$CFld?5?9?$DO?5?$CFld?5in?5?$CF1?42f?5sec?4?6?$AA@
	call	_printf
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+496], 1
	adc	DWORD PTR [eax+500], 0
	pop	eax

; 66   : 		ftell(in), ftell(out), double(clock() - start) / CLOCKS_PER_SEC);
; 67   : 
; 68   : 	fclose(in);

	mov	esi, DWORD PTR __imp__fclose
	push	ebx
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+504], 1
	adc	DWORD PTR [eax+508], 0
	pop	eax

; 69   : 	fclose(out);

	push	ebp
	call	esi
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+512], 1
	adc	DWORD PTR [eax+516], 0
	pop	eax
	add	esp, 28					; 0000001cH

; 70   : 	return 0;

	xor	eax, eax
	pop	ebx
	jmp	SHORT $LN10@main
$LN12@main:

; 22   : 
; 23   : 	// Check arguments
; 24   : 	if ((argc != 4) || ((argv[1][0] != 'c') && (argv[1][0] != 'd'))) {

	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+520], 1
	adc	DWORD PTR [eax+524], 0
	pop	eax
$LN3@main:

; 25   : 		printf("<exe> c/d <input> <output>\n");

	push	OFFSET ??_C@_0BM@KFKAIBDI@?$DMexe?$DO?5c?1d?5?$DMinput?$DO?5?$DMoutput?$DO?6?$AA@
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+528], 1
	adc	DWORD PTR [eax+532], 0
	pop	eax
	call	_printf
	push	eax
	mov	eax, DWORD PTR __PogoGlobalProbes
	add	DWORD PTR [eax+536], 1
	adc	DWORD PTR [eax+540], 0
	pop	eax
	add	esp, 4

; 26   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@main
$LN10@main:
	pop	ebp
	pop	esi
$LN1@main:

; 71   : }

	pop	edi
	add	esp, 52					; 00000034H
	ret	0
$LN11@main:
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.11.25503\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 151  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 152  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??$fillmem@E@@YAXPAEHE@Z
_TEXT	SEGMENT
??$fillmem@E@@YAXPAEHE@Z PROC				; fillmem<unsigned char>, COMDAT
; External Pogo thunk for ??$fillmem@E@@YAXPAEHE@Z
	pop	eax
	push	213					; 000000d5H
	push	0
	push	eax
	jmp	??$fillmem@E@@YAXPAEHE@Z		; fillmem<unsigned char>
??$fillmem@E@@YAXPAEHE@Z ENDP				; fillmem<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ods
;	COMDAT ??$fillmem@K@@YAXPAKHK@Z
_TEXT	SEGMENT
??$fillmem@K@@YAXPAKHK@Z PROC				; fillmem<unsigned long>, COMDAT
; External Pogo thunk for ??$fillmem@K@@YAXPAKHK@Z
	pop	eax
	push	212					; 000000d4H
	push	0
	push	eax
	jmp	??$fillmem@K@@YAXPAKHK@Z		; fillmem<unsigned long>
??$fillmem@K@@YAXPAKHK@Z ENDP				; fillmem<unsigned long>
_TEXT	ENDS
END
